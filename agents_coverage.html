
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agents: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/killallgit/ryan/pkg/agents/code_analysis.go (81.3%)</option>
				
				<option value="file1">github.com/killallgit/ryan/pkg/agents/code_review.go (67.8%)</option>
				
				<option value="file2">github.com/killallgit/ryan/pkg/agents/context.go (8.3%)</option>
				
				<option value="file3">github.com/killallgit/ryan/pkg/agents/conversational_agent.go (0.0%)</option>
				
				<option value="file4">github.com/killallgit/ryan/pkg/agents/dispatcher.go (90.2%)</option>
				
				<option value="file5">github.com/killallgit/ryan/pkg/agents/executor.go (69.1%)</option>
				
				<option value="file6">github.com/killallgit/ryan/pkg/agents/factory.go (43.5%)</option>
				
				<option value="file7">github.com/killallgit/ryan/pkg/agents/feedback.go (7.6%)</option>
				
				<option value="file8">github.com/killallgit/ryan/pkg/agents/file_operations.go (0.0%)</option>
				
				<option value="file9">github.com/killallgit/ryan/pkg/agents/langchain_agent.go (0.0%)</option>
				
				<option value="file10">github.com/killallgit/ryan/pkg/agents/langchain_orchestrator.go (0.0%)</option>
				
				<option value="file11">github.com/killallgit/ryan/pkg/agents/ollama_functions_agent.go (0.0%)</option>
				
				<option value="file12">github.com/killallgit/ryan/pkg/agents/openai_functions_agent.go (0.0%)</option>
				
				<option value="file13">github.com/killallgit/ryan/pkg/agents/orchestrator.go (73.2%)</option>
				
				<option value="file14">github.com/killallgit/ryan/pkg/agents/planner.go (86.0%)</option>
				
				<option value="file15">github.com/killallgit/ryan/pkg/agents/protocol.go (0.0%)</option>
				
				<option value="file16">github.com/killallgit/ryan/pkg/agents/search.go (79.3%)</option>
				
				<option value="file17">github.com/killallgit/ryan/pkg/agents/utils.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package agents

import (
        "context"
        "fmt"
        "go/ast"
        "go/parser"
        "go/token"
        "strings"
        "time"

        "github.com/killallgit/ryan/pkg/logger"
)

// CodeAnalysisAgent performs AST analysis, symbol resolution, and code understanding
type CodeAnalysisAgent struct {
        astAnalyzer    *ASTAnalyzer
        symbolResolver *SymbolResolver
        log            *logger.Logger
}

// NewCodeAnalysisAgent creates a new code analysis agent
func NewCodeAnalysisAgent() *CodeAnalysisAgent <span class="cov8" title="1">{
        return &amp;CodeAnalysisAgent{
                astAnalyzer:    NewASTAnalyzer(),
                symbolResolver: NewSymbolResolver(),
                log:            logger.WithComponent("code_analysis_agent"),
        }
}</span>

// Name returns the agent name
func (c *CodeAnalysisAgent) Name() string <span class="cov8" title="1">{
        return "code_analysis"
}</span>

// Description returns the agent description
func (c *CodeAnalysisAgent) Description() string <span class="cov8" title="1">{
        return "Performs AST analysis, symbol resolution, and code structure understanding"
}</span>

// CanHandle determines if this agent can handle the request
func (c *CodeAnalysisAgent) CanHandle(request string) (bool, float64) <span class="cov8" title="1">{
        lowerRequest := strings.ToLower(request)
        
        keywords := []string{
                "analyze", "ast", "structure", "symbols",
                "functions", "types", "interfaces", "patterns",
        }
        
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                if strings.Contains(lowerRequest, keyword) </span><span class="cov8" title="1">{
                        return true, 0.8
                }</span>
        }
        
        <span class="cov8" title="1">return false, 0.0</span>
}

// Execute performs code analysis
func (c *CodeAnalysisAgent) Execute(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        c.log.Info("Executing code analysis", "prompt", request.Prompt)

        // Get file contents from context
        fileContents, err := c.getFileContents(request)
        if err != nil </span><span class="cov8" title="1">{
                return AgentResult{
                        Success: false,
                        Summary: "Failed to get file contents",
                        Details: err.Error(),
                }, err
        }</span>

        // Analyze each file
        <span class="cov8" title="1">analysisResults := make(map[string]*FileAnalysis)
        var allSymbols []Symbol
        var allFunctions []Function
        var allTypes []Type

        for filePath, content := range fileContents </span><span class="cov8" title="1">{
                if strings.HasSuffix(filePath, ".go") </span><span class="cov8" title="1">{
                        analysis, err := c.analyzeGoFile(filePath, content)
                        if err != nil </span><span class="cov0" title="0">{
                                c.log.Warn("Failed to analyze file", "file", filePath, "error", err)
                                continue</span>
                        }
                        
                        <span class="cov8" title="1">analysisResults[filePath] = analysis
                        allSymbols = append(allSymbols, analysis.Symbols...)
                        allFunctions = append(allFunctions, analysis.Functions...)
                        allTypes = append(allTypes, analysis.Types...)</span>
                }
        }

        // Build summary and details
        <span class="cov8" title="1">summary := c.buildSummary(analysisResults)
        details := c.buildDetails(analysisResults)

        return AgentResult{
                Success: true,
                Summary: summary,
                Details: details,
                Artifacts: map[string]interface{}{
                        "analysis_results": analysisResults,
                        "symbols":          allSymbols,
                        "functions":        allFunctions,
                        "types":            allTypes,
                },
                Metadata: AgentMetadata{
                        AgentName:      c.Name(),
                        StartTime:      startTime,
                        EndTime:        time.Now(),
                        Duration:       time.Since(startTime),
                        FilesProcessed: getKeys(analysisResults),
                },
        }, nil</span>
}

// getFileContents retrieves file contents from the request context
func (c *CodeAnalysisAgent) getFileContents(request AgentRequest) (map[string]string, error) <span class="cov8" title="1">{
        // Check execution context
        if execContext, ok := request.Context["execution_context"].(*ExecutionContext); ok </span><span class="cov0" title="0">{
                if fileContents, ok := execContext.SharedData["file_contents"].(map[string]string); ok </span><span class="cov0" title="0">{
                        return fileContents, nil
                }</span>
        }

        // Check direct context
        <span class="cov8" title="1">if fileContents, ok := request.Context["file_contents"].(map[string]string); ok </span><span class="cov8" title="1">{
                return fileContents, nil
        }</span>

        // Check artifacts
        <span class="cov8" title="1">if artifacts, ok := request.Context["artifacts"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if fileContents, ok := artifacts["file_contents"].(map[string]string); ok </span><span class="cov0" title="0">{
                        return fileContents, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("no file contents found in context")</span>
}

// analyzeGoFile analyzes a single Go file
func (c *CodeAnalysisAgent) analyzeGoFile(filePath, content string) (*FileAnalysis, error) <span class="cov8" title="1">{
        fset := token.NewFileSet()
        node, err := parser.ParseFile(fset, filePath, content, parser.ParseComments)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">analysis := &amp;FileAnalysis{
                FilePath:  filePath,
                Package:   node.Name.Name,
                Imports:   c.extractImports(node),
                Functions: []Function{},
                Types:     []Type{},
                Symbols:   []Symbol{},
        }

        // Walk the AST
        ast.Inspect(node, func(n ast.Node) bool </span><span class="cov8" title="1">{
                switch x := n.(type) </span>{
                case *ast.FuncDecl:<span class="cov8" title="1">
                        fn := c.extractFunction(x, fset)
                        analysis.Functions = append(analysis.Functions, fn)
                        analysis.Symbols = append(analysis.Symbols, Symbol{
                                Name: fn.Name,
                                Type: "function",
                                Pos:  fn.Position,
                        })</span>
                        
                case *ast.GenDecl:<span class="cov8" title="1">
                        if x.Tok == token.TYPE </span><span class="cov8" title="1">{
                                for _, spec := range x.Specs </span><span class="cov8" title="1">{
                                        if typeSpec, ok := spec.(*ast.TypeSpec); ok </span><span class="cov8" title="1">{
                                                typ := c.extractType(typeSpec, fset)
                                                analysis.Types = append(analysis.Types, typ)
                                                analysis.Symbols = append(analysis.Symbols, Symbol{
                                                        Name: typ.Name,
                                                        Type: "type",
                                                        Pos:  typ.Position,
                                                })
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">return true</span>
        })

        <span class="cov8" title="1">return analysis, nil</span>
}

// Helper methods for extraction

func (c *CodeAnalysisAgent) extractImports(file *ast.File) []string <span class="cov8" title="1">{
        var imports []string
        for _, imp := range file.Imports </span><span class="cov8" title="1">{
                path := imp.Path.Value
                imports = append(imports, strings.Trim(path, `"`))
        }</span>
        <span class="cov8" title="1">return imports</span>
}

func (c *CodeAnalysisAgent) extractFunction(fn *ast.FuncDecl, fset *token.FileSet) Function <span class="cov8" title="1">{
        pos := fset.Position(fn.Pos())
        
        function := Function{
                Name:     fn.Name.Name,
                Position: fmt.Sprintf("%s:%d", pos.Filename, pos.Line),
                Params:   []string{},
                Returns:  []string{},
        }

        // Extract receiver
        if fn.Recv != nil &amp;&amp; len(fn.Recv.List) &gt; 0 </span><span class="cov0" title="0">{
                function.Receiver = c.typeToString(fn.Recv.List[0].Type)
        }</span>

        // Extract parameters
        <span class="cov8" title="1">if fn.Type.Params != nil </span><span class="cov8" title="1">{
                for _, param := range fn.Type.Params.List </span><span class="cov0" title="0">{
                        paramType := c.typeToString(param.Type)
                        for range param.Names </span><span class="cov0" title="0">{
                                function.Params = append(function.Params, paramType)
                        }</span>
                }
        }

        // Extract return types
        <span class="cov8" title="1">if fn.Type.Results != nil </span><span class="cov8" title="1">{
                for _, result := range fn.Type.Results.List </span><span class="cov8" title="1">{
                        function.Returns = append(function.Returns, c.typeToString(result.Type))
                }</span>
        }

        <span class="cov8" title="1">return function</span>
}

func (c *CodeAnalysisAgent) extractType(spec *ast.TypeSpec, fset *token.FileSet) Type <span class="cov8" title="1">{
        pos := fset.Position(spec.Pos())
        
        typ := Type{
                Name:     spec.Name.Name,
                Position: fmt.Sprintf("%s:%d", pos.Filename, pos.Line),
        }

        // Determine type kind
        switch t := spec.Type.(type) </span>{
        case *ast.StructType:<span class="cov0" title="0">
                typ.Kind = "struct"
                typ.Fields = c.extractStructFields(t)</span>
        case *ast.InterfaceType:<span class="cov8" title="1">
                typ.Kind = "interface"
                typ.Methods = c.extractInterfaceMethods(t)</span>
        default:<span class="cov0" title="0">
                typ.Kind = "alias"</span>
        }

        <span class="cov8" title="1">return typ</span>
}

func (c *CodeAnalysisAgent) extractStructFields(s *ast.StructType) []Field <span class="cov0" title="0">{
        var fields []Field
        for _, field := range s.Fields.List </span><span class="cov0" title="0">{
                fieldType := c.typeToString(field.Type)
                for _, name := range field.Names </span><span class="cov0" title="0">{
                        fields = append(fields, Field{
                                Name: name.Name,
                                Type: fieldType,
                        })
                }</span>
        }
        <span class="cov0" title="0">return fields</span>
}

func (c *CodeAnalysisAgent) extractInterfaceMethods(i *ast.InterfaceType) []Method <span class="cov8" title="1">{
        var methods []Method
        for _, method := range i.Methods.List </span><span class="cov8" title="1">{
                if _, ok := method.Type.(*ast.FuncType); ok </span><span class="cov8" title="1">{
                        for _, name := range method.Names </span><span class="cov8" title="1">{
                                methods = append(methods, Method{
                                        Name: name.Name,
                                })
                        }</span>
                }
        }
        <span class="cov8" title="1">return methods</span>
}

func (c *CodeAnalysisAgent) typeToString(expr ast.Expr) string <span class="cov8" title="1">{
        switch t := expr.(type) </span>{
        case *ast.Ident:<span class="cov8" title="1">
                return t.Name</span>
        case *ast.StarExpr:<span class="cov0" title="0">
                return "*" + c.typeToString(t.X)</span>
        case *ast.ArrayType:<span class="cov0" title="0">
                return "[]" + c.typeToString(t.Elt)</span>
        case *ast.SelectorExpr:<span class="cov0" title="0">
                return c.typeToString(t.X) + "." + t.Sel.Name</span>
        default:<span class="cov0" title="0">
                return "interface{}"</span>
        }
}

// Build summary and details

func (c *CodeAnalysisAgent) buildSummary(results map[string]*FileAnalysis) string <span class="cov8" title="1">{
        totalFunctions := 0
        totalTypes := 0
        totalSymbols := 0

        for _, analysis := range results </span><span class="cov8" title="1">{
                totalFunctions += len(analysis.Functions)
                totalTypes += len(analysis.Types)
                totalSymbols += len(analysis.Symbols)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("Analyzed %d files: found %d functions, %d types, %d total symbols",
                len(results), totalFunctions, totalTypes, totalSymbols)</span>
}

func (c *CodeAnalysisAgent) buildDetails(results map[string]*FileAnalysis) string <span class="cov8" title="1">{
        var details []string

        for filePath, analysis := range results </span><span class="cov8" title="1">{
                details = append(details, fmt.Sprintf("File: %s", filePath))
                details = append(details, fmt.Sprintf("  Package: %s", analysis.Package))
                
                if len(analysis.Functions) &gt; 0 </span><span class="cov8" title="1">{
                        details = append(details, "  Functions:")
                        for _, fn := range analysis.Functions </span><span class="cov8" title="1">{
                                sig := fn.Name
                                if fn.Receiver != "" </span><span class="cov0" title="0">{
                                        sig = fmt.Sprintf("(%s) %s", fn.Receiver, fn.Name)
                                }</span>
                                <span class="cov8" title="1">details = append(details, fmt.Sprintf("    - %s", sig))</span>
                        }
                }

                <span class="cov8" title="1">if len(analysis.Types) &gt; 0 </span><span class="cov8" title="1">{
                        details = append(details, "  Types:")
                        for _, typ := range analysis.Types </span><span class="cov8" title="1">{
                                details = append(details, fmt.Sprintf("    - %s (%s)", typ.Name, typ.Kind))
                        }</span>
                }

                <span class="cov8" title="1">details = append(details, "")</span>
        }

        <span class="cov8" title="1">return strings.Join(details, "\n")</span>
}

// Supporting types

type FileAnalysis struct {
        FilePath  string
        Package   string
        Imports   []string
        Functions []Function
        Types     []Type
        Symbols   []Symbol
}

type Symbol struct {
        Name string
        Type string
        Pos  string
}

type Function struct {
        Name     string
        Receiver string
        Params   []string
        Returns  []string
        Position string
}

type Type struct {
        Name     string
        Kind     string // struct, interface, alias
        Fields   []Field
        Methods  []Method
        Position string
}

type Field struct {
        Name string
        Type string
}

type Method struct {
        Name string
}

// Helper components

type ASTAnalyzer struct{}

func NewASTAnalyzer() *ASTAnalyzer <span class="cov8" title="1">{
        return &amp;ASTAnalyzer{}
}</span>

type SymbolResolver struct{}

func NewSymbolResolver() *SymbolResolver <span class="cov8" title="1">{
        return &amp;SymbolResolver{}
}</span>

// Utility function
func getKeys(m map[string]*FileAnalysis) []string <span class="cov8" title="1">{
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package agents

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/killallgit/ryan/pkg/logger"
)

// CodeReviewAgent performs comprehensive code reviews using context from other agents
type CodeReviewAgent struct {
        reviewEngine  *ReviewEngine
        issueDetector *IssueDetector
        log           *logger.Logger
}

// NewCodeReviewAgent creates a new code review agent
func NewCodeReviewAgent() *CodeReviewAgent <span class="cov8" title="1">{
        return &amp;CodeReviewAgent{
                reviewEngine:  NewReviewEngine(),
                issueDetector: NewIssueDetector(),
                log:           logger.WithComponent("code_review_agent"),
        }
}</span>

// Name returns the agent name
func (c *CodeReviewAgent) Name() string <span class="cov8" title="1">{
        return "code_review"
}</span>

// Description returns the agent description
func (c *CodeReviewAgent) Description() string <span class="cov8" title="1">{
        return "Performs comprehensive code reviews with architectural analysis and best practices"
}</span>

// CanHandle determines if this agent can handle the request
func (c *CodeReviewAgent) CanHandle(request string) (bool, float64) <span class="cov8" title="1">{
        lowerRequest := strings.ToLower(request)
        
        keywords := []string{
                "code review", "review", "critique", "feedback",
                "improve", "suggestions", "best practices",
        }
        
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                if strings.Contains(lowerRequest, keyword) </span><span class="cov8" title="1">{
                        return true, 0.9
                }</span>
        }
        
        <span class="cov8" title="1">return false, 0.0</span>
}

// Execute performs the code review
func (c *CodeReviewAgent) Execute(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        c.log.Info("Executing code review", "prompt", request.Prompt)

        // Get analysis results from context
        analysisResults, err := c.getAnalysisResults(request)
        if err != nil </span><span class="cov8" title="1">{
                c.log.Warn("No analysis results found, performing basic review", "error", err)
        }</span>

        // Get file contents
        <span class="cov8" title="1">fileContents, err := c.getFileContents(request)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Failed to get file contents",
                        Details: err.Error(),
                }, err
        }</span>

        // Perform review
        <span class="cov8" title="1">review := c.performReview(fileContents, analysisResults)

        // Build summary and details
        summary := c.buildSummary(review)
        details := c.buildDetails(review)

        return AgentResult{
                Success: true,
                Summary: summary,
                Details: details,
                Artifacts: map[string]interface{}{
                        "review":           review,
                        "issues":           review.Issues,
                        "suggestions":      review.Suggestions,
                        "positive_aspects": review.PositiveAspects,
                },
                Metadata: AgentMetadata{
                        AgentName:      c.Name(),
                        StartTime:      startTime,
                        EndTime:        time.Now(),
                        Duration:       time.Since(startTime),
                        FilesProcessed: review.FilesReviewed,
                },
        }, nil</span>
}

// getAnalysisResults retrieves code analysis results from context
func (c *CodeReviewAgent) getAnalysisResults(request AgentRequest) (map[string]*FileAnalysis, error) <span class="cov8" title="1">{
        // Check execution context
        if execContext, ok := request.Context["execution_context"].(*ExecutionContext); ok </span><span class="cov0" title="0">{
                if results, ok := execContext.SharedData["analysis_results"].(map[string]*FileAnalysis); ok </span><span class="cov0" title="0">{
                        return results, nil
                }</span>
        }

        // Check artifacts
        <span class="cov8" title="1">if artifacts, ok := request.Context["artifacts"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if results, ok := artifacts["analysis_results"].(map[string]*FileAnalysis); ok </span><span class="cov0" title="0">{
                        return results, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("no analysis results found")</span>
}

// getFileContents retrieves file contents from context
func (c *CodeReviewAgent) getFileContents(request AgentRequest) (map[string]string, error) <span class="cov8" title="1">{
        // Check execution context
        if execContext, ok := request.Context["execution_context"].(*ExecutionContext); ok </span><span class="cov0" title="0">{
                if fileContents, ok := execContext.SharedData["file_contents"].(map[string]string); ok </span><span class="cov0" title="0">{
                        return fileContents, nil
                }</span>
        }

        // Check direct context
        <span class="cov8" title="1">if fileContents, ok := request.Context["file_contents"].(map[string]string); ok </span><span class="cov8" title="1">{
                return fileContents, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no file contents found in context")</span>
}

// performReview performs the actual code review
func (c *CodeReviewAgent) performReview(fileContents map[string]string, analysisResults map[string]*FileAnalysis) *CodeReview <span class="cov8" title="1">{
        review := &amp;CodeReview{
                ReviewID:        generateID(),
                Timestamp:       time.Now(),
                FilesReviewed:   make([]string, 0, len(fileContents)),
                Issues:          []Issue{},
                Suggestions:     []Suggestion{},
                PositiveAspects: []string{},
                OverallScore:    0,
        }

        // Review each file
        for filePath, content := range fileContents </span><span class="cov8" title="1">{
                review.FilesReviewed = append(review.FilesReviewed, filePath)
                
                // Get analysis for this file if available
                var analysis *FileAnalysis
                if analysisResults != nil </span><span class="cov0" title="0">{
                        analysis = analysisResults[filePath]
                }</span>

                // Perform various checks
                <span class="cov8" title="1">fileIssues := c.reviewFile(filePath, content, analysis)
                review.Issues = append(review.Issues, fileIssues...)

                // Generate suggestions
                fileSuggestions := c.generateSuggestions(filePath, content, analysis)
                review.Suggestions = append(review.Suggestions, fileSuggestions...)

                // Note positive aspects
                positives := c.findPositiveAspects(filePath, content, analysis)
                review.PositiveAspects = append(review.PositiveAspects, positives...)</span>
        }

        // Calculate overall score
        <span class="cov8" title="1">review.OverallScore = c.calculateScore(review)

        return review</span>
}

// reviewFile performs various checks on a single file
func (c *CodeReviewAgent) reviewFile(filePath, content string, analysis *FileAnalysis) []Issue <span class="cov8" title="1">{
        issues := []Issue{}

        // Check code style
        styleIssues := c.issueDetector.CheckStyle(filePath, content)
        issues = append(issues, styleIssues...)

        // Check complexity
        if analysis != nil </span><span class="cov0" title="0">{
                for _, fn := range analysis.Functions </span><span class="cov0" title="0">{
                        if c.isFunctionComplex(fn, content) </span><span class="cov0" title="0">{
                                issues = append(issues, Issue{
                                        File:     filePath,
                                        Line:     fn.Position,
                                        Severity: "warning",
                                        Type:     "complexity",
                                        Message:  fmt.Sprintf("Function %s appears to be complex and might benefit from refactoring", fn.Name),
                                })
                        }</span>
                }
        }

        // Check for common issues
        <span class="cov8" title="1">commonIssues := c.issueDetector.CheckCommonIssues(filePath, content)
        issues = append(issues, commonIssues...)

        return issues</span>
}

// generateSuggestions creates improvement suggestions
func (c *CodeReviewAgent) generateSuggestions(filePath, content string, analysis *FileAnalysis) []Suggestion <span class="cov8" title="1">{
        suggestions := []Suggestion{}

        // Architecture suggestions
        if analysis != nil &amp;&amp; len(analysis.Types) &gt; 10 </span><span class="cov0" title="0">{
                suggestions = append(suggestions, Suggestion{
                        File:     filePath,
                        Type:     "architecture",
                        Priority: "medium",
                        Message:  "Consider splitting this file into smaller, more focused modules",
                        Details:  fmt.Sprintf("This file contains %d type definitions which might indicate it's doing too much", len(analysis.Types)),
                })
        }</span>

        // Testing suggestions
        <span class="cov8" title="1">if strings.HasSuffix(filePath, ".go") &amp;&amp; !strings.HasSuffix(filePath, "_test.go") </span><span class="cov8" title="1">{
                hasTests := false
                // Simple check - in real implementation would check for corresponding test file
                if !hasTests </span><span class="cov8" title="1">{
                        suggestions = append(suggestions, Suggestion{
                                File:     filePath,
                                Type:     "testing",
                                Priority: "high",
                                Message:  "Consider adding unit tests for this file",
                                Details:  "No corresponding test file found",
                        })
                }</span>
        }

        // Documentation suggestions
        <span class="cov8" title="1">if analysis != nil </span><span class="cov0" title="0">{
                for _, fn := range analysis.Functions </span><span class="cov0" title="0">{
                        if fn.Receiver == "" &amp;&amp; !strings.HasPrefix(fn.Name, "new") &amp;&amp; !strings.HasPrefix(fn.Name, "New") </span><span class="cov0" title="0">{
                                // Check if function has comment (simplified check)
                                if !strings.Contains(content, fmt.Sprintf("// %s", fn.Name)) </span><span class="cov0" title="0">{
                                        suggestions = append(suggestions, Suggestion{
                                                File:     filePath,
                                                Type:     "documentation",
                                                Priority: "low",
                                                Message:  fmt.Sprintf("Consider adding documentation for exported function %s", fn.Name),
                                                Details:  "Exported functions should have documentation comments",
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return suggestions</span>
}

// findPositiveAspects identifies good practices in the code
func (c *CodeReviewAgent) findPositiveAspects(filePath, content string, analysis *FileAnalysis) []string <span class="cov8" title="1">{
        positives := []string{}

        // Check for good practices
        if strings.Contains(content, "context.Context") </span><span class="cov0" title="0">{
                positives = append(positives, fmt.Sprintf("%s: Good use of context for cancellation and timeouts", filePath))
        }</span>

        <span class="cov8" title="1">if strings.Contains(content, "defer") </span><span class="cov8" title="1">{
                positives = append(positives, fmt.Sprintf("%s: Proper use of defer for cleanup", filePath))
        }</span>

        <span class="cov8" title="1">if analysis != nil </span><span class="cov0" title="0">{
                // Check for interface usage
                interfaceCount := 0
                for _, typ := range analysis.Types </span><span class="cov0" title="0">{
                        if typ.Kind == "interface" </span><span class="cov0" title="0">{
                                interfaceCount++
                        }</span>
                }
                <span class="cov0" title="0">if interfaceCount &gt; 0 </span><span class="cov0" title="0">{
                        positives = append(positives, fmt.Sprintf("%s: Good use of interfaces for abstraction", filePath))
                }</span>
        }

        <span class="cov8" title="1">return positives</span>
}

// Helper methods

func (c *CodeReviewAgent) isFunctionComplex(fn Function, content string) bool <span class="cov0" title="0">{
        // Simple complexity check - count lines
        // In real implementation would use cyclomatic complexity
        lines := strings.Split(content, "\n")
        functionLines := 0
        inFunction := false
        
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, fmt.Sprintf("func %s", fn.Name)) </span><span class="cov0" title="0">{
                        inFunction = true
                }</span>
                <span class="cov0" title="0">if inFunction </span><span class="cov0" title="0">{
                        functionLines++
                        if strings.TrimSpace(line) == "}" </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return functionLines &gt; 50</span>
}

func (c *CodeReviewAgent) calculateScore(review *CodeReview) float64 <span class="cov8" title="1">{
        // Simple scoring algorithm
        score := 100.0
        
        // Deduct points for issues
        for _, issue := range review.Issues </span><span class="cov0" title="0">{
                switch issue.Severity </span>{
                case "error":<span class="cov0" title="0">
                        score -= 10</span>
                case "warning":<span class="cov0" title="0">
                        score -= 5</span>
                case "info":<span class="cov0" title="0">
                        score -= 2</span>
                }
        }
        
        // Add points for positive aspects
        <span class="cov8" title="1">score += float64(len(review.PositiveAspects)) * 2
        
        // Ensure score is within bounds
        if score &lt; 0 </span><span class="cov0" title="0">{
                score = 0
        }</span>
        <span class="cov8" title="1">if score &gt; 100 </span><span class="cov8" title="1">{
                score = 100
        }</span>
        
        <span class="cov8" title="1">return score</span>
}

func (c *CodeReviewAgent) buildSummary(review *CodeReview) string <span class="cov8" title="1">{
        return fmt.Sprintf("Reviewed %d files: found %d issues, made %d suggestions. Overall score: %.1f/100",
                len(review.FilesReviewed),
                len(review.Issues),
                len(review.Suggestions),
                review.OverallScore,
        )
}</span>

func (c *CodeReviewAgent) buildDetails(review *CodeReview) string <span class="cov8" title="1">{
        var details []string

        details = append(details, fmt.Sprintf("Code Review Report (ID: %s)", review.ReviewID))
        details = append(details, fmt.Sprintf("Timestamp: %s", review.Timestamp.Format(time.RFC3339)))
        details = append(details, fmt.Sprintf("Overall Score: %.1f/100", review.OverallScore))
        details = append(details, "")

        if len(review.Issues) &gt; 0 </span><span class="cov0" title="0">{
                details = append(details, "## Issues Found:")
                for _, issue := range review.Issues </span><span class="cov0" title="0">{
                        details = append(details, fmt.Sprintf("- [%s] %s: %s (%s)",
                                issue.Severity, issue.File, issue.Message, issue.Type))
                }</span>
                <span class="cov0" title="0">details = append(details, "")</span>
        }

        <span class="cov8" title="1">if len(review.Suggestions) &gt; 0 </span><span class="cov8" title="1">{
                details = append(details, "## Suggestions:")
                for _, suggestion := range review.Suggestions </span><span class="cov8" title="1">{
                        details = append(details, fmt.Sprintf("- [%s] %s: %s",
                                suggestion.Priority, suggestion.File, suggestion.Message))
                        if suggestion.Details != "" </span><span class="cov8" title="1">{
                                details = append(details, fmt.Sprintf("  Details: %s", suggestion.Details))
                        }</span>
                }
                <span class="cov8" title="1">details = append(details, "")</span>
        }

        <span class="cov8" title="1">if len(review.PositiveAspects) &gt; 0 </span><span class="cov8" title="1">{
                details = append(details, "## Positive Aspects:")
                for _, positive := range review.PositiveAspects </span><span class="cov8" title="1">{
                        details = append(details, fmt.Sprintf("- %s", positive))
                }</span>
                <span class="cov8" title="1">details = append(details, "")</span>
        }

        <span class="cov8" title="1">return strings.Join(details, "\n")</span>
}

// Supporting types

type CodeReview struct {
        ReviewID        string
        Timestamp       time.Time
        FilesReviewed   []string
        Issues          []Issue
        Suggestions     []Suggestion
        PositiveAspects []string
        OverallScore    float64
}

type Issue struct {
        File     string
        Line     string
        Severity string // error, warning, info
        Type     string // style, complexity, bug, security
        Message  string
}

type Suggestion struct {
        File     string
        Type     string // architecture, testing, documentation, performance
        Priority string // high, medium, low
        Message  string
        Details  string
}

// Helper components

type ReviewEngine struct{}

func NewReviewEngine() *ReviewEngine <span class="cov8" title="1">{
        return &amp;ReviewEngine{}
}</span>

type IssueDetector struct{}

func NewIssueDetector() *IssueDetector <span class="cov8" title="1">{
        return &amp;IssueDetector{}
}</span>

func (i *IssueDetector) CheckStyle(filePath, content string) []Issue <span class="cov8" title="1">{
        issues := []Issue{}
        
        // Simple style checks
        lines := strings.Split(content, "\n")
        for idx, line := range lines </span><span class="cov8" title="1">{
                // Check line length
                if len(line) &gt; 120 </span><span class="cov0" title="0">{
                        issues = append(issues, Issue{
                                File:     filePath,
                                Line:     fmt.Sprintf("%d", idx+1),
                                Severity: "info",
                                Type:     "style",
                                Message:  "Line exceeds 120 characters",
                        })
                }</span>
                
                // Check for TODO comments
                <span class="cov8" title="1">if strings.Contains(line, "TODO") </span><span class="cov0" title="0">{
                        issues = append(issues, Issue{
                                File:     filePath,
                                Line:     fmt.Sprintf("%d", idx+1),
                                Severity: "info",
                                Type:     "style",
                                Message:  "TODO comment found",
                        })
                }</span>
        }
        
        <span class="cov8" title="1">return issues</span>
}

func (i *IssueDetector) CheckCommonIssues(filePath, content string) []Issue <span class="cov8" title="1">{
        issues := []Issue{}
        
        // Check for common Go issues
        if strings.HasSuffix(filePath, ".go") </span><span class="cov8" title="1">{
                // Check for error handling
                if strings.Contains(content, "err != nil") &amp;&amp; !strings.Contains(content, "if err != nil") </span><span class="cov0" title="0">{
                        issues = append(issues, Issue{
                                File:     filePath,
                                Line:     "various",
                                Severity: "warning",
                                Type:     "bug",
                                Message:  "Potential unhandled error",
                        })
                }</span>
                
                // Check for resource leaks
                <span class="cov8" title="1">if strings.Contains(content, "defer") &amp;&amp; strings.Contains(content, ".Close()") </span>{<span class="cov8" title="1">
                        // Good - has defer close
                }</span> else<span class="cov8" title="1"> if strings.Contains(content, ".Open") || strings.Contains(content, "net.Dial") </span><span class="cov0" title="0">{
                        issues = append(issues, Issue{
                                File:     filePath,
                                Line:     "various",
                                Severity: "warning",
                                Type:     "bug",
                                Message:  "Potential resource leak - ensure resources are properly closed",
                        })
                }</span>
        }
        
        <span class="cov8" title="1">return issues</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package agents

import (
        "strings"
        "sync"

        "github.com/killallgit/ryan/pkg/logger"
)

// ContextManager manages shared state and context between agents
type ContextManager struct {
        sharedMemory    *SharedMemory
        contextTree     *ContextTree
        propagator      *ContextPropagator
        log             *logger.Logger
}

// NewContextManager creates a new context manager
func NewContextManager() *ContextManager <span class="cov8" title="1">{
        return &amp;ContextManager{
                sharedMemory:    NewSharedMemory(),
                contextTree:     NewContextTree(),
                propagator:      NewContextPropagator(),
                log:             logger.WithComponent("context_manager"),
        }
}</span>

// CreateContext creates a new execution context
func (cm *ContextManager) CreateContext(sessionID, requestID, userPrompt string) *ExecutionContext <span class="cov8" title="1">{
        return &amp;ExecutionContext{
                SessionID:   sessionID,
                RequestID:   requestID,
                UserPrompt:  userPrompt,
                SharedData:  make(map[string]interface{}),
                FileContext: []FileInfo{},
                Artifacts:   make(map[string]interface{}),
                Options:     make(map[string]interface{}),
        }
}</span>

// PropagateContext propagates relevant context from one execution to another
func (cm *ContextManager) PropagateContext(from, to *ExecutionContext, targetAgent string) <span class="cov0" title="0">{
        cm.propagator.Propagate(from, to, targetAgent)
}</span>

// SharedMemory manages shared data between agents
type SharedMemory struct {
        data map[string]interface{}
        mu   sync.RWMutex
}

// NewSharedMemory creates a new shared memory
func NewSharedMemory() *SharedMemory <span class="cov8" title="1">{
        return &amp;SharedMemory{
                data: make(map[string]interface{}),
        }
}</span>

// Set stores a value in shared memory
func (sm *SharedMemory) Set(key string, value interface{}) <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        sm.data[key] = value
}</span>

// Get retrieves a value from shared memory
func (sm *SharedMemory) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()
        value, exists := sm.data[key]
        return value, exists
}</span>

// GetAll returns all data in shared memory
func (sm *SharedMemory) GetAll() map[string]interface{} <span class="cov0" title="0">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()
        
        copy := make(map[string]interface{})
        for k, v := range sm.data </span><span class="cov0" title="0">{
                copy[k] = v
        }</span>
        <span class="cov0" title="0">return copy</span>
}

// ContextTree manages hierarchical context relationships
type ContextTree struct {
        root  *ContextNode
        nodes map[string]*ContextNode
        mu    sync.RWMutex
}

// NewContextTree creates a new context tree
func NewContextTree() *ContextTree <span class="cov8" title="1">{
        root := &amp;ContextNode{
                ID:       "root",
                Children: make([]*ContextNode, 0),
                Data:     make(map[string]interface{}),
        }
        
        return &amp;ContextTree{
                root:  root,
                nodes: map[string]*ContextNode{"root": root},
        }
}</span>

// AddNode adds a node to the context tree
func (ct *ContextTree) AddNode(id, parentID string, data map[string]interface{}) error <span class="cov0" title="0">{
        ct.mu.Lock()
        defer ct.mu.Unlock()

        parent, exists := ct.nodes[parentID]
        if !exists </span><span class="cov0" title="0">{
                parent = ct.root
        }</span>

        <span class="cov0" title="0">node := &amp;ContextNode{
                ID:       id,
                Parent:   parent,
                Children: make([]*ContextNode, 0),
                Data:     data,
        }

        parent.Children = append(parent.Children, node)
        ct.nodes[id] = node

        return nil</span>
}

// GetNode retrieves a node from the tree
func (ct *ContextTree) GetNode(id string) (*ContextNode, bool) <span class="cov0" title="0">{
        ct.mu.RLock()
        defer ct.mu.RUnlock()
        
        node, exists := ct.nodes[id]
        return node, exists
}</span>

// GetPath returns the path from root to a node
func (ct *ContextTree) GetPath(nodeID string) []*ContextNode <span class="cov0" title="0">{
        ct.mu.RLock()
        defer ct.mu.RUnlock()

        node, exists := ct.nodes[nodeID]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">path := make([]*ContextNode, 0)
        current := node
        for current != nil </span><span class="cov0" title="0">{
                path = append([]*ContextNode{current}, path...)
                current = current.Parent
        }</span>

        <span class="cov0" title="0">return path</span>
}

// ContextNode represents a node in the context tree
type ContextNode struct {
        ID       string
        Parent   *ContextNode
        Children []*ContextNode
        Data     map[string]interface{}
}

// ContextPropagator handles intelligent context propagation
type ContextPropagator struct {
        rules []PropagationRule
        log   *logger.Logger
}

// NewContextPropagator creates a new context propagator
func NewContextPropagator() *ContextPropagator <span class="cov8" title="1">{
        return &amp;ContextPropagator{
                rules: defaultPropagationRules(),
                log:   logger.WithComponent("context_propagator"),
        }
}</span>

// Propagate propagates context based on rules
func (cp *ContextPropagator) Propagate(from, to *ExecutionContext, targetAgent string) <span class="cov0" title="0">{
        cp.log.Debug("Propagating context", "target_agent", targetAgent)

        // Apply propagation rules
        for _, rule := range cp.rules </span><span class="cov0" title="0">{
                if rule.ShouldApply(targetAgent) </span><span class="cov0" title="0">{
                        rule.Apply(from, to, targetAgent)
                }</span>
        }
}

// PropagationRule defines how context should be propagated
type PropagationRule interface {
        ShouldApply(targetAgent string) bool
        Apply(from, to *ExecutionContext, targetAgent string)
}

// FileContextRule propagates file context
type FileContextRule struct{}

func (r *FileContextRule) ShouldApply(targetAgent string) bool <span class="cov0" title="0">{
        // File context is relevant for most agents
        return true
}</span>

func (r *FileContextRule) Apply(from, to *ExecutionContext, targetAgent string) <span class="cov0" title="0">{
        from.mu.RLock()
        defer from.mu.RUnlock()
        to.mu.Lock()
        defer to.mu.Unlock()

        // Copy file context
        for _, file := range from.FileContext </span><span class="cov0" title="0">{
                // Check if file already exists
                exists := false
                for _, existing := range to.FileContext </span><span class="cov0" title="0">{
                        if existing.Path == file.Path </span><span class="cov0" title="0">{
                                exists = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        to.FileContext = append(to.FileContext, file)
                }</span>
        }
}

// SharedDataRule propagates shared data selectively
type SharedDataRule struct{}

func (r *SharedDataRule) ShouldApply(targetAgent string) bool <span class="cov0" title="0">{
        return true
}</span>

func (r *SharedDataRule) Apply(from, to *ExecutionContext, targetAgent string) <span class="cov0" title="0">{
        from.mu.RLock()
        defer from.mu.RUnlock()
        to.mu.Lock()
        defer to.mu.Unlock()

        // Copy relevant shared data
        for key, value := range from.SharedData </span><span class="cov0" title="0">{
                // Filter based on key patterns
                if shouldPropagateKey(key, targetAgent) </span><span class="cov0" title="0">{
                        to.SharedData[key] = value
                }</span>
        }
}

// shouldPropagateKey determines if a key should be propagated to an agent
func shouldPropagateKey(key, targetAgent string) bool <span class="cov0" title="0">{
        // Agent-specific filtering logic
        switch targetAgent </span>{
        case "code_review":<span class="cov0" title="0">
                // Code review needs analysis results
                return strings.Contains(key, "analysis") || strings.Contains(key, "ast")</span>
        case "file_operations":<span class="cov0" title="0">
                // File operations needs file-related data
                return strings.Contains(key, "file") || strings.Contains(key, "path")</span>
        default:<span class="cov0" title="0">
                // Default: propagate most data
                return !strings.Contains(key, "internal")</span>
        }
}

// ArtifactsRule propagates artifacts
type ArtifactsRule struct{}

func (r *ArtifactsRule) ShouldApply(targetAgent string) bool <span class="cov0" title="0">{
        // Artifacts are useful for most agents
        return targetAgent != "dispatcher"
}</span>

func (r *ArtifactsRule) Apply(from, to *ExecutionContext, targetAgent string) <span class="cov0" title="0">{
        from.mu.RLock()
        defer from.mu.RUnlock()
        to.mu.Lock()
        defer to.mu.Unlock()

        if from.Artifacts != nil &amp;&amp; len(from.Artifacts) &gt; 0 </span><span class="cov0" title="0">{
                if to.Artifacts == nil </span><span class="cov0" title="0">{
                        to.Artifacts = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">for k, v := range from.Artifacts </span><span class="cov0" title="0">{
                        to.Artifacts[k] = v
                }</span>
        }
}

// defaultPropagationRules returns the default set of propagation rules
func defaultPropagationRules() []PropagationRule <span class="cov8" title="1">{
        return []PropagationRule{
                &amp;FileContextRule{},
                &amp;SharedDataRule{},
                &amp;ArtifactsRule{},
        }
}</pre>
		
		<pre class="file" id="file3" style="display: none">package agents

import (
        "context"
        "fmt"
        "strings"
        
        "github.com/killallgit/ryan/pkg/langchain"
        "github.com/killallgit/ryan/pkg/logger"
        "github.com/killallgit/ryan/pkg/models"
)

// ConversationalAgent implements a ReAct-style conversational agent
type ConversationalAgent struct {
        BaseLangchainAgent
        client *langchain.Client
        log    *logger.Logger
}

// NewConversationalAgent creates a new conversational agent
func NewConversationalAgent(config AgentConfig) (LangchainAgent, error) <span class="cov0" title="0">{
        client, err := langchain.NewClient(config.BaseURL, config.Model, config.ToolRegistry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create langchain client: %w", err)
        }</span>
        
        <span class="cov0" title="0">agent := &amp;ConversationalAgent{
                BaseLangchainAgent: BaseLangchainAgent{
                        name:         "conversational",
                        description:  "ReAct-style conversational agent with tool usage through natural language",
                        chainType:    ChainTypeReAct,
                        toolRegistry: config.ToolRegistry,
                        model:        config.Model,
                        requirements: ModelRequirements{
                                MinToolCompatibility: models.ToolCompatibilityGood,
                                RequiredFeatures:     []string{"reasoning", "tool_description"},
                                PreferredModels:      []string{"claude", "gpt-4", "llama3"},
                        },
                },
                client: client,
                log:    logger.WithComponent("conversational_agent"),
        }
        
        return agent, nil</span>
}

// CanHandle determines if this agent can handle the request
func (c *ConversationalAgent) CanHandle(request string) (bool, float64) <span class="cov0" title="0">{
        // Conversational agent can handle most requests but with varying confidence
        lowerRequest := strings.ToLower(request)
        
        // High confidence for conversational and reasoning tasks
        if strings.Contains(lowerRequest, "explain") ||
                strings.Contains(lowerRequest, "think") ||
                strings.Contains(lowerRequest, "reason") ||
                strings.Contains(lowerRequest, "analyze") </span><span class="cov0" title="0">{
                return true, 0.9
        }</span>
        
        // Medium confidence for tool usage
        <span class="cov0" title="0">if c.toolRegistry != nil &amp;&amp; c.toolRegistry.HasTools() </span><span class="cov0" title="0">{
                return true, 0.7
        }</span>
        
        // Low confidence as fallback
        <span class="cov0" title="0">return true, 0.5</span>
}

// Execute performs the agent's task
func (c *ConversationalAgent) Execute(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        c.log.Debug("Executing conversational agent",
                "prompt", request.Prompt,
                "model", c.model)
        
        // Send message through the langchain client
        response, err := c.client.SendMessage(ctx, request.Prompt)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Failed to execute conversational agent",
                        Details: err.Error(),
                }, err
        }</span>
        
        <span class="cov0" title="0">return AgentResult{
                Success: true,
                Summary: "Conversational agent completed successfully",
                Details: response,
                Metadata: AgentMetadata{
                        AgentName: c.name,
                },
        }, nil</span>
}

// GetToolCompatibility returns tools this agent can use
func (c *ConversationalAgent) GetToolCompatibility() []string <span class="cov0" title="0">{
        if c.toolRegistry == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        
        <span class="cov0" title="0">tools := c.toolRegistry.GetTools()
        toolNames := make([]string, 0, len(tools))
        for _, tool := range tools </span><span class="cov0" title="0">{
                toolNames = append(toolNames, tool.Name())
        }</span>
        <span class="cov0" title="0">return toolNames</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package agents

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/killallgit/ryan/pkg/logger"
)

// DispatcherAgent is the main entry point that analyzes prompts and dispatches to other agents
type DispatcherAgent struct {
        orchestrator *Orchestrator
        planner      *Planner
        log          *logger.Logger
}

// NewDispatcherAgent creates a new dispatcher agent
func NewDispatcherAgent(orchestrator *Orchestrator) *DispatcherAgent <span class="cov8" title="1">{
        return &amp;DispatcherAgent{
                orchestrator: orchestrator,
                planner:      orchestrator.planner,
                log:          logger.WithComponent("dispatcher_agent"),
        }
}</span>

// Name returns the agent name
func (d *DispatcherAgent) Name() string <span class="cov8" title="1">{
        return "dispatcher"
}</span>

// Description returns the agent description
func (d *DispatcherAgent) Description() string <span class="cov8" title="1">{
        return "Analyzes user prompts and creates execution plans for other agents"
}</span>

// CanHandle determines if this agent can handle the request
func (d *DispatcherAgent) CanHandle(request string) (bool, float64) <span class="cov0" title="0">{
        // Dispatcher can handle any request as the entry point
        return true, 1.0
}</span>

// Execute analyzes the request and creates an execution plan
func (d *DispatcherAgent) Execute(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        d.log.Info("Analyzing request", "prompt_preview", truncateString(request.Prompt, 100))

        // Create execution context if not provided
        execContext, ok := request.Context["execution_context"].(*ExecutionContext)
        if !ok </span><span class="cov0" title="0">{
                execContext = &amp;ExecutionContext{
                        SessionID:   generateID(),
                        RequestID:   generateID(),
                        UserPrompt:  request.Prompt,
                        SharedData:  make(map[string]interface{}),
                        FileContext: []FileInfo{},
                        Progress:    make(chan ProgressUpdate, 100),
                        Options:     request.Options,
                }
        }</span>

        // Create execution plan
        <span class="cov8" title="1">plan, err := d.planner.CreateExecutionPlan(ctx, request.Prompt, execContext)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Failed to create execution plan",
                        Details: err.Error(),
                        Metadata: AgentMetadata{
                                AgentName: d.Name(),
                                StartTime: startTime,
                                EndTime:   time.Now(),
                                Duration:  time.Since(startTime),
                        },
                }, err
        }</span>

        // Store plan in context
        <span class="cov8" title="1">execContext.SharedData["execution_plan"] = plan

        // Build summary of the plan
        summary := d.buildPlanSummary(plan)

        // Build details
        details := d.buildPlanDetails(plan)

        return AgentResult{
                Success: true,
                Summary: summary,
                Details: details,
                Artifacts: map[string]interface{}{
                        "plan":            plan,
                        "execution_context": execContext,
                },
                Metadata: AgentMetadata{
                        AgentName: d.Name(),
                        StartTime: startTime,
                        EndTime:   time.Now(),
                        Duration:  time.Since(startTime),
                },
        }, nil</span>
}

// buildPlanSummary creates a summary of the execution plan
func (d *DispatcherAgent) buildPlanSummary(plan *ExecutionPlan) string <span class="cov8" title="1">{
        agents := make(map[string]int)
        for _, task := range plan.Tasks </span><span class="cov8" title="1">{
                agents[task.Agent]++
        }</span>

        <span class="cov8" title="1">parts := []string{
                fmt.Sprintf("Created plan with %d tasks", len(plan.Tasks)),
                fmt.Sprintf("across %d stages", len(plan.Stages)),
        }

        // List agents involved
        agentList := []string{}
        for agent, count := range agents </span><span class="cov8" title="1">{
                agentList = append(agentList, fmt.Sprintf("%s (%d)", agent, count))
        }</span>
        <span class="cov8" title="1">if len(agentList) &gt; 0 </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("using agents: %s", strings.Join(agentList, ", ")))
        }</span>

        <span class="cov8" title="1">return strings.Join(parts, " ")</span>
}

// buildPlanDetails creates detailed description of the execution plan
func (d *DispatcherAgent) buildPlanDetails(plan *ExecutionPlan) string <span class="cov8" title="1">{
        var details []string

        details = append(details, fmt.Sprintf("Execution Plan ID: %s", plan.ID))
        details = append(details, fmt.Sprintf("Estimated Duration: %s", plan.EstimatedDuration))
        details = append(details, "")

        // Detail each stage
        for i, stage := range plan.Stages </span><span class="cov8" title="1">{
                details = append(details, fmt.Sprintf("Stage %d (%s):", i+1, stage.ID))
                
                for _, taskID := range stage.Tasks </span><span class="cov8" title="1">{
                        // Find task details
                        for _, task := range plan.Tasks </span><span class="cov8" title="1">{
                                if task.ID == taskID </span><span class="cov8" title="1">{
                                        details = append(details, fmt.Sprintf("  - %s: %s", 
                                                task.Agent, 
                                                truncateString(task.Request.Prompt, 60)))
                                        if len(task.Dependencies) &gt; 0 </span><span class="cov0" title="0">{
                                                details = append(details, fmt.Sprintf("    Dependencies: %s", 
                                                        strings.Join(task.Dependencies, ", ")))
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                }
                <span class="cov8" title="1">details = append(details, "")</span>
        }

        <span class="cov8" title="1">return strings.Join(details, "\n")</span>
}

</pre>
		
		<pre class="file" id="file5" style="display: none">package agents

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/killallgit/ryan/pkg/logger"
)

// Executor handles parallel and sequential agent execution
type Executor struct {
        orchestrator    *Orchestrator
        workerPool      *WorkerPool
        taskQueue       *TaskQueue
        dependencyGraph *DependencyGraph
        progressTracker *ProgressTracker
        log             *logger.Logger
}

// NewExecutor creates a new executor
func NewExecutor() *Executor <span class="cov8" title="1">{
        return &amp;Executor{
                workerPool:      NewWorkerPool(10), // 10 concurrent workers
                taskQueue:       NewTaskQueue(),
                dependencyGraph: NewDependencyGraph(),
                progressTracker: NewProgressTracker(),
                log:             logger.WithComponent("executor"),
        }
}</span>

// SetOrchestrator sets the orchestrator reference
func (e *Executor) SetOrchestrator(o *Orchestrator) <span class="cov8" title="1">{
        e.orchestrator = o
}</span>

// ExecutePlan executes an execution plan
func (e *Executor) ExecutePlan(ctx context.Context, plan *ExecutionPlan, execContext *ExecutionContext) ([]TaskResult, error) <span class="cov8" title="1">{
        e.log.Info("Executing plan", "plan_id", plan.ID, "tasks", len(plan.Tasks), "stages", len(plan.Stages))

        // Initialize progress tracking
        e.progressTracker.StartPlan(plan.ID, len(plan.Tasks))
        defer e.progressTracker.CompletePlan(plan.ID)

        // Build dependency graph
        e.dependencyGraph.BuildFromPlan(plan)

        // Execute stages in order
        results := make([]TaskResult, 0, len(plan.Tasks))
        resultsMux := &amp;sync.Mutex{}

        for _, stage := range plan.Stages </span><span class="cov8" title="1">{
                e.log.Debug("Executing stage", "stage_id", stage.ID, "tasks", len(stage.Tasks))

                // Execute tasks in this stage concurrently
                stageResults, err := e.executeStage(ctx, stage, plan, execContext, resultsMux)
                if err != nil </span><span class="cov0" title="0">{
                        return results, fmt.Errorf("stage %s failed: %w", stage.ID, err)
                }</span>

                <span class="cov8" title="1">results = append(results, stageResults...)</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// executeStage executes all tasks in a stage concurrently
func (e *Executor) executeStage(ctx context.Context, stage Stage, plan *ExecutionPlan, execContext *ExecutionContext, resultsMux *sync.Mutex) ([]TaskResult, error) <span class="cov8" title="1">{
        var wg sync.WaitGroup
        results := make([]TaskResult, 0, len(stage.Tasks))
        errors := make(chan error, len(stage.Tasks))

        for _, taskID := range stage.Tasks </span><span class="cov8" title="1">{
                // Find task in plan
                var task *Task
                for i := range plan.Tasks </span><span class="cov8" title="1">{
                        if plan.Tasks[i].ID == taskID </span><span class="cov8" title="1">{
                                task = &amp;plan.Tasks[i]
                                break</span>
                        }
                }
                <span class="cov8" title="1">if task == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">wg.Add(1)
                go func(t Task) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        result, err := e.executeTask(ctx, t, execContext)
                        if err != nil </span><span class="cov0" title="0">{
                                errors &lt;- err
                                return
                        }</span>

                        <span class="cov8" title="1">resultsMux.Lock()
                        results = append(results, result)
                        resultsMux.Unlock()</span>
                }(*task)
        }

        // Wait for all tasks to complete
        <span class="cov8" title="1">wg.Wait()
        close(errors)

        // Check for errors
        for err := range errors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return results, err
                }</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// executeTask executes a single task
func (e *Executor) executeTask(ctx context.Context, task Task, execContext *ExecutionContext) (TaskResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        e.log.Info("Executing task", "task_id", task.ID, "agent", task.Agent)

        // Update progress
        e.progressTracker.StartTask(task.ID)
        defer e.progressTracker.CompleteTask(task.ID)

        // Get agent
        agent, err := e.orchestrator.GetAgent(task.Agent)
        if err != nil </span><span class="cov0" title="0">{
                return TaskResult{
                        Task: task,
                        Result: AgentResult{
                                Success: false,
                                Summary: fmt.Sprintf("Agent %s not found", task.Agent),
                                Details: err.Error(),
                        },
                        Error: err,
                }, err
        }</span>

        // Prepare agent request with context
        <span class="cov8" title="1">request := task.Request
        request.Context = e.prepareTaskContext(task, execContext)

        // Execute agent
        result, err := agent.Execute(ctx, request)
        if err != nil </span><span class="cov8" title="1">{
                e.log.Error("Task execution failed", "task_id", task.ID, "error", err)
                return TaskResult{
                        Task:   task,
                        Result: result,
                        Error:  err,
                }, nil // Don't propagate error to allow other tasks to continue
        }</span>

        // Update execution context with results
        <span class="cov8" title="1">e.updateExecutionContext(task, result, execContext)

        // Send progress update
        if execContext.Progress != nil </span><span class="cov8" title="1">{
                select </span>{
                case execContext.Progress &lt;- ProgressUpdate{
                        TaskID:    task.ID,
                        Agent:     task.Agent,
                        Status:    "completed",
                        Timestamp: time.Now(),
                }:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel full, skip
                }
        }

        <span class="cov8" title="1">return TaskResult{
                Task:      task,
                Result:    result,
                Error:     nil,
                StartTime: startTime,
                EndTime:   time.Now(),
        }, nil</span>
}

// prepareTaskContext prepares the context for a task
func (e *Executor) prepareTaskContext(task Task, execContext *ExecutionContext) map[string]interface{} <span class="cov8" title="1">{
        context := make(map[string]interface{})

        // Copy base context
        for k, v := range task.Request.Context </span><span class="cov0" title="0">{
                context[k] = v
        }</span>

        // Add execution context references
        <span class="cov8" title="1">context["execution_context"] = execContext
        context["orchestrator"] = e.orchestrator
        context["shared_data"] = execContext.SharedData
        context["file_context"] = execContext.FileContext

        return context</span>
}

// updateExecutionContext updates the execution context with task results
func (e *Executor) updateExecutionContext(task Task, result AgentResult, execContext *ExecutionContext) <span class="cov8" title="1">{
        // Store result in shared data
        execContext.mu.Lock()
        defer execContext.mu.Unlock()

        if execContext.SharedData == nil </span><span class="cov0" title="0">{
                execContext.SharedData = make(map[string]interface{})
        }</span>

        // Store task result
        <span class="cov8" title="1">execContext.SharedData[fmt.Sprintf("task_%s_result", task.ID)] = result

        // Update file context if agent processed files
        if len(result.Metadata.FilesProcessed) &gt; 0 </span><span class="cov0" title="0">{
                for _, file := range result.Metadata.FilesProcessed </span><span class="cov0" title="0">{
                        // Check if file already in context
                        found := false
                        for _, f := range execContext.FileContext </span><span class="cov0" title="0">{
                                if f.Path == file </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                execContext.FileContext = append(execContext.FileContext, FileInfo{
                                        Path:         file,
                                        LastModified: time.Now(),
                                })
                        }</span>
                }
        }

        // Store any artifacts
        <span class="cov8" title="1">if result.Artifacts != nil </span><span class="cov8" title="1">{
                if execContext.Artifacts == nil </span><span class="cov8" title="1">{
                        execContext.Artifacts = make(map[string]interface{})
                }</span>
                <span class="cov8" title="1">for k, v := range result.Artifacts </span><span class="cov8" title="1">{
                        execContext.Artifacts[fmt.Sprintf("%s_%s", task.Agent, k)] = v
                }</span>
        }
}

// WorkerPool manages concurrent task execution
type WorkerPool struct {
        workers    int
        taskChan   chan func()
        workerWg   sync.WaitGroup
        shutdownCh chan struct{}
}

// NewWorkerPool creates a new worker pool
func NewWorkerPool(workers int) *WorkerPool <span class="cov8" title="1">{
        wp := &amp;WorkerPool{
                workers:    workers,
                taskChan:   make(chan func(), workers*2),
                shutdownCh: make(chan struct{}),
        }

        // Start workers
        for i := 0; i &lt; workers; i++ </span><span class="cov8" title="1">{
                wp.workerWg.Add(1)
                go wp.worker()
        }</span>

        <span class="cov8" title="1">return wp</span>
}

// worker processes tasks from the queue
func (wp *WorkerPool) worker() <span class="cov8" title="1">{
        defer wp.workerWg.Done()

        for </span><span class="cov8" title="1">{
                select </span>{
                case task := &lt;-wp.taskChan:<span class="cov0" title="0">
                        if task != nil </span><span class="cov0" title="0">{
                                task()
                        }</span>
                case &lt;-wp.shutdownCh:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// Submit submits a task to the worker pool
func (wp *WorkerPool) Submit(task func()) <span class="cov0" title="0">{
        select </span>{
        case wp.taskChan &lt;- task:<span class="cov0" title="0"></span>
        case &lt;-wp.shutdownCh:<span class="cov0" title="0"></span>
                // Pool is shutting down
        }
}

// Shutdown gracefully shuts down the worker pool
func (wp *WorkerPool) Shutdown() <span class="cov0" title="0">{
        close(wp.shutdownCh)
        wp.workerWg.Wait()
}</span>

// TaskQueue manages task queueing
type TaskQueue struct {
        queue []Task
        mu    sync.Mutex
}

// NewTaskQueue creates a new task queue
func NewTaskQueue() *TaskQueue <span class="cov8" title="1">{
        return &amp;TaskQueue{
                queue: make([]Task, 0),
        }
}</span>

// Enqueue adds a task to the queue
func (tq *TaskQueue) Enqueue(task Task) <span class="cov0" title="0">{
        tq.mu.Lock()
        defer tq.mu.Unlock()
        tq.queue = append(tq.queue, task)
}</span>

// Dequeue removes and returns a task from the queue
func (tq *TaskQueue) Dequeue() (Task, bool) <span class="cov0" title="0">{
        tq.mu.Lock()
        defer tq.mu.Unlock()

        if len(tq.queue) == 0 </span><span class="cov0" title="0">{
                return Task{}, false
        }</span>

        <span class="cov0" title="0">task := tq.queue[0]
        tq.queue = tq.queue[1:]
        return task, true</span>
}

// DependencyGraph manages task dependencies
type DependencyGraph struct {
        dependencies map[string][]string
        mu           sync.RWMutex
}

// NewDependencyGraph creates a new dependency graph
func NewDependencyGraph() *DependencyGraph <span class="cov8" title="1">{
        return &amp;DependencyGraph{
                dependencies: make(map[string][]string),
        }
}</span>

// BuildFromPlan builds the dependency graph from an execution plan
func (dg *DependencyGraph) BuildFromPlan(plan *ExecutionPlan) <span class="cov8" title="1">{
        dg.mu.Lock()
        defer dg.mu.Unlock()

        dg.dependencies = make(map[string][]string)
        for _, task := range plan.Tasks </span><span class="cov8" title="1">{
                dg.dependencies[task.ID] = task.Dependencies
        }</span>
}

// CanExecute checks if a task can be executed (all dependencies satisfied)
func (dg *DependencyGraph) CanExecute(taskID string, completed map[string]bool) bool <span class="cov0" title="0">{
        dg.mu.RLock()
        defer dg.mu.RUnlock()

        deps, exists := dg.dependencies[taskID]
        if !exists </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">for _, dep := range deps </span><span class="cov0" title="0">{
                if !completed[dep] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// ProgressTracker tracks execution progress
type ProgressTracker struct {
        plans map[string]*PlanProgress
        mu    sync.RWMutex
}

// NewProgressTracker creates a new progress tracker
func NewProgressTracker() *ProgressTracker <span class="cov8" title="1">{
        return &amp;ProgressTracker{
                plans: make(map[string]*PlanProgress),
        }
}</span>

// StartPlan starts tracking a plan
func (pt *ProgressTracker) StartPlan(planID string, totalTasks int) <span class="cov8" title="1">{
        pt.mu.Lock()
        defer pt.mu.Unlock()

        pt.plans[planID] = &amp;PlanProgress{
                PlanID:     planID,
                TotalTasks: totalTasks,
                StartTime:  time.Now(),
                TaskStatus: make(map[string]string),
        }
}</span>

// StartTask marks a task as started
func (pt *ProgressTracker) StartTask(taskID string) <span class="cov8" title="1">{
        pt.mu.Lock()
        defer pt.mu.Unlock()

        for _, progress := range pt.plans </span><span class="cov8" title="1">{
                progress.TaskStatus[taskID] = "running"
        }</span>
}

// CompleteTask marks a task as completed
func (pt *ProgressTracker) CompleteTask(taskID string) <span class="cov8" title="1">{
        pt.mu.Lock()
        defer pt.mu.Unlock()

        for _, progress := range pt.plans </span><span class="cov8" title="1">{
                if progress.TaskStatus[taskID] == "running" </span><span class="cov8" title="1">{
                        progress.TaskStatus[taskID] = "completed"
                        progress.CompletedTasks++
                }</span>
        }
}

// CompletePlan marks a plan as completed
func (pt *ProgressTracker) CompletePlan(planID string) <span class="cov8" title="1">{
        pt.mu.Lock()
        defer pt.mu.Unlock()

        if progress, exists := pt.plans[planID]; exists </span><span class="cov8" title="1">{
                progress.EndTime = time.Now()
                progress.Completed = true
        }</span>
}

// GetProgress returns the current progress of a plan
func (pt *ProgressTracker) GetProgress(planID string) (*PlanProgress, bool) <span class="cov0" title="0">{
        pt.mu.RLock()
        defer pt.mu.RUnlock()

        progress, exists := pt.plans[planID]
        return progress, exists
}</span>

// PlanProgress represents the progress of a plan
type PlanProgress struct {
        PlanID         string
        TotalTasks     int
        CompletedTasks int
        StartTime      time.Time
        EndTime        time.Time
        Completed      bool
        TaskStatus     map[string]string
}</pre>
		
		<pre class="file" id="file6" style="display: none">package agents

import (
        "fmt"
        "sync"
        
        "github.com/killallgit/ryan/pkg/logger"
)

// AgentFactoryFunc is a function that creates an agent
type AgentFactoryFunc func(config AgentConfig) (LangchainAgent, error)

// AgentFactory manages the creation and registration of agents
type AgentFactory struct {
        registry map[string]AgentFactoryFunc
        mu       sync.RWMutex
        log      *logger.Logger
}

// NewAgentFactory creates a new agent factory
func NewAgentFactory() *AgentFactory <span class="cov8" title="1">{
        factory := &amp;AgentFactory{
                registry: make(map[string]AgentFactoryFunc),
                log:      logger.WithComponent("agent_factory"),
        }
        
        // Register default agents
        factory.RegisterDefaults()
        
        return factory
}</span>

// RegisterDefaults registers all default agent types
func (f *AgentFactory) RegisterDefaults() <span class="cov8" title="1">{
        f.Register("conversational", NewConversationalAgent)
        f.Register("ollama-functions", NewOllamaFunctionsAgent)
        f.Register("openai-functions", NewOpenAIFunctionsAgent)
        f.Register("react", NewConversationalAgent) // Alias for conversational
        
        f.log.Debug("Registered default agents",
                "count", len(f.registry),
                "types", f.GetRegisteredTypes())
}</span>

// Register registers a new agent factory function
func (f *AgentFactory) Register(agentType string, factoryFunc AgentFactoryFunc) error <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        
        if _, exists := f.registry[agentType]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("agent type %s is already registered", agentType)
        }</span>
        
        <span class="cov8" title="1">f.registry[agentType] = factoryFunc
        f.log.Debug("Registered agent type", "type", agentType)
        return nil</span>
}

// Create creates an agent of the specified type
func (f *AgentFactory) Create(agentType string, config AgentConfig) (LangchainAgent, error) <span class="cov0" title="0">{
        f.mu.RLock()
        factoryFunc, exists := f.registry[agentType]
        f.mu.RUnlock()
        
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unknown agent type: %s", agentType)
        }</span>
        
        <span class="cov0" title="0">agent, err := factoryFunc(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create agent %s: %w", agentType, err)
        }</span>
        
        <span class="cov0" title="0">f.log.Debug("Created agent",
                "type", agentType,
                "model", config.Model)
        
        return agent, nil</span>
}

// GetRegisteredTypes returns all registered agent types
func (f *AgentFactory) GetRegisteredTypes() []string <span class="cov8" title="1">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        
        types := make([]string, 0, len(f.registry))
        for agentType := range f.registry </span><span class="cov8" title="1">{
                types = append(types, agentType)
        }</span>
        <span class="cov8" title="1">return types</span>
}

// IsRegistered checks if an agent type is registered
func (f *AgentFactory) IsRegistered(agentType string) bool <span class="cov0" title="0">{
        f.mu.RLock()
        defer f.mu.RUnlock()
        
        _, exists := f.registry[agentType]
        return exists
}</span>

// CreateBestAgent creates the best agent for the given configuration and request
func (f *AgentFactory) CreateBestAgent(config AgentConfig, request string) (LangchainAgent, error) <span class="cov0" title="0">{
        // Try to create agents in order of preference
        preferences := []string{"ollama-functions", "openai-functions", "conversational"}
        
        for _, agentType := range preferences </span><span class="cov0" title="0">{
                agent, err := f.Create(agentType, config)
                if err != nil </span><span class="cov0" title="0">{
                        f.log.Debug("Failed to create agent type",
                                "type", agentType,
                                "error", err)
                        continue</span>
                }
                
                // Check if agent can handle the request
                <span class="cov0" title="0">canHandle, confidence := agent.CanHandle(request)
                if canHandle &amp;&amp; confidence &gt; 0.5 </span><span class="cov0" title="0">{
                        f.log.Debug("Selected agent",
                                "type", agentType,
                                "confidence", confidence)
                        return agent, nil
                }</span>
        }
        
        // Fallback to conversational agent
        <span class="cov0" title="0">return f.Create("conversational", config)</span>
}

// GlobalFactory is the global agent factory instance
var GlobalFactory = NewAgentFactory()</pre>
		
		<pre class="file" id="file7" style="display: none">package agents

import (
        "context"
        "fmt"
        "time"

        "github.com/killallgit/ryan/pkg/logger"
)

// FeedbackLoop handles feedback processing and learning
type FeedbackLoop struct {
        orchestrator *Orchestrator
        validator    *ResultValidator
        corrector    *AutoCorrector
        learner      *PatternLearner
        log          *logger.Logger
}

// NewFeedbackLoop creates a new feedback loop
func NewFeedbackLoop() *FeedbackLoop <span class="cov8" title="1">{
        return &amp;FeedbackLoop{
                validator: NewResultValidator(),
                corrector: NewAutoCorrector(),
                learner:   NewPatternLearner(),
                log:       logger.WithComponent("feedback_loop"),
        }
}</span>

// SetOrchestrator sets the orchestrator reference
func (fl *FeedbackLoop) SetOrchestrator(o *Orchestrator) <span class="cov8" title="1">{
        fl.orchestrator = o
}</span>

// ProcessFeedback processes feedback from agent execution
func (fl *FeedbackLoop) ProcessFeedback(ctx context.Context, feedback *FeedbackRequest) error <span class="cov0" title="0">{
        fl.log.Info("Processing feedback", "type", feedback.Type, "source", feedback.SourceTask)

        switch feedback.Type </span>{
        case FeedbackTypeNeedMoreContext:<span class="cov0" title="0">
                return fl.handleNeedMoreContext(ctx, feedback)</span>
        case FeedbackTypeValidationError:<span class="cov0" title="0">
                return fl.handleValidationError(ctx, feedback)</span>
        case FeedbackTypeRetry:<span class="cov0" title="0">
                return fl.handleRetry(ctx, feedback)</span>
        case FeedbackTypeRefine:<span class="cov0" title="0">
                return fl.handleRefine(ctx, feedback)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown feedback type: %s", feedback.Type)</span>
        }
}

// handleNeedMoreContext handles requests for additional context
func (fl *FeedbackLoop) handleNeedMoreContext(ctx context.Context, feedback *FeedbackRequest) error <span class="cov0" title="0">{
        fl.log.Debug("Handling need more context feedback")

        // Extract what context is needed
        contextRequest, ok := feedback.Content.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid context request format")
        }</span>

        // Create a new task to gather the requested context
        <span class="cov0" title="0">contextType, _ := contextRequest["type"].(string)
        target, _ := contextRequest["target"].(string)

        // Build a new execution plan for context gathering
        plan := &amp;ExecutionPlan{
                ID:      generateID(),
                Context: feedback.Context,
                Tasks: []Task{
                        {
                                ID:    generateID(),
                                Agent: "file_operations",
                                Request: AgentRequest{
                                        Prompt: fmt.Sprintf("Gather additional context about %s for %s", target, contextType),
                                        Context: map[string]interface{}{
                                                "original_request": feedback.SourceTask,
                                                "context_type":     contextType,
                                        },
                                },
                                Priority: int(PriorityHigh),
                        },
                },
                Stages: []Stage{
                        {
                                ID:    "context-gathering",
                                Tasks: []string{},
                        },
                },
        }

        // Execute the context gathering plan
        results, err := fl.orchestrator.ExecuteWithPlan(ctx, plan, feedback.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to gather additional context: %w", err)
        }</span>

        // Update the execution context with new information
        <span class="cov0" title="0">if len(results) &gt; 0 &amp;&amp; results[0].Result.Success </span><span class="cov0" title="0">{
                feedback.Context.mu.Lock()
                feedback.Context.SharedData["additional_context"] = results[0].Result
                feedback.Context.mu.Unlock()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// handleValidationError handles validation errors
func (fl *FeedbackLoop) handleValidationError(ctx context.Context, feedback *FeedbackRequest) error <span class="cov0" title="0">{
        fl.log.Debug("Handling validation error feedback")

        // Analyze the validation error
        validationResult := fl.validator.Analyze(feedback)

        // Attempt automatic correction
        if validationResult.CanAutoCorrect </span><span class="cov0" title="0">{
                correction := fl.corrector.GenerateCorrection(validationResult)
                if correction != nil </span><span class="cov0" title="0">{
                        // Apply correction by re-executing with modified parameters
                        return fl.applyCorrection(ctx, feedback, correction)
                }</span>
        }

        // Learn from the error
        <span class="cov0" title="0">fl.learner.RecordPattern(feedback, validationResult)

        return nil</span>
}

// handleRetry handles retry requests
func (fl *FeedbackLoop) handleRetry(ctx context.Context, feedback *FeedbackRequest) error <span class="cov0" title="0">{
        fl.log.Debug("Handling retry feedback")

        // Extract retry parameters
        retryParams, ok := feedback.Content.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                retryParams = make(map[string]interface{})
        }</span>

        // Modify the original request based on feedback
        <span class="cov0" title="0">modifiedRequest := fl.modifyRequestForRetry(feedback, retryParams)

        // Re-execute the task
        agent, err := fl.orchestrator.GetAgent(feedback.TargetTask)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("agent not found for retry: %w", err)
        }</span>

        <span class="cov0" title="0">result, err := agent.Execute(ctx, modifiedRequest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("retry execution failed: %w", err)
        }</span>

        // Update context with retry result
        <span class="cov0" title="0">feedback.Context.mu.Lock()
        feedback.Context.SharedData[fmt.Sprintf("retry_%s_result", feedback.SourceTask)] = result
        feedback.Context.mu.Unlock()

        return nil</span>
}

// handleRefine handles refinement requests
func (fl *FeedbackLoop) handleRefine(ctx context.Context, feedback *FeedbackRequest) error <span class="cov0" title="0">{
        fl.log.Debug("Handling refine feedback")

        // Extract refinement parameters
        refineParams, ok := feedback.Content.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid refinement parameters")
        }</span>

        // Create a refinement plan
        <span class="cov0" title="0">plan := fl.createRefinementPlan(feedback, refineParams)

        // Execute refinement
        results, err := fl.orchestrator.ExecuteWithPlan(ctx, plan, feedback.Context)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("refinement execution failed: %w", err)
        }</span>

        // Aggregate refined results
        <span class="cov0" title="0">fl.aggregateRefinedResults(feedback.Context, results)

        return nil</span>
}

// Helper methods

func (fl *FeedbackLoop) modifyRequestForRetry(feedback *FeedbackRequest, params map[string]interface{}) AgentRequest <span class="cov0" title="0">{
        // Create modified request based on feedback
        return AgentRequest{
                Prompt: fmt.Sprintf("Retry: %v", feedback.Content),
                Context: map[string]interface{}{
                        "retry_attempt": true,
                        "original_task": feedback.SourceTask,
                        "retry_params":  params,
                },
        }
}</span>

func (fl *FeedbackLoop) createRefinementPlan(feedback *FeedbackRequest, params map[string]interface{}) *ExecutionPlan <span class="cov0" title="0">{
        // Create a plan for refinement
        return &amp;ExecutionPlan{
                ID:      generateID(),
                Context: feedback.Context,
                Tasks:   []Task{}, // Would be populated based on refinement needs
                Stages:  []Stage{},
        }
}</span>

func (fl *FeedbackLoop) aggregateRefinedResults(context *ExecutionContext, results []TaskResult) <span class="cov0" title="0">{
        context.mu.Lock()
        defer context.mu.Unlock()

        refinedData := make(map[string]interface{})
        for _, result := range results </span><span class="cov0" title="0">{
                if result.Result.Success </span><span class="cov0" title="0">{
                        refinedData[result.Task.ID] = result.Result
                }</span>
        }

        <span class="cov0" title="0">context.SharedData["refined_results"] = refinedData</span>
}

func (fl *FeedbackLoop) applyCorrection(ctx context.Context, feedback *FeedbackRequest, correction *Correction) error <span class="cov0" title="0">{
        // Apply the correction by modifying and re-executing
        return nil
}</span>

// ResultValidator validates agent results
type ResultValidator struct {
        rules []ValidationRule
        log   *logger.Logger
}

// NewResultValidator creates a new result validator
func NewResultValidator() *ResultValidator <span class="cov8" title="1">{
        return &amp;ResultValidator{
                rules: defaultValidationRules(),
                log:   logger.WithComponent("result_validator"),
        }
}</span>

// Analyze analyzes a feedback request for validation issues
func (rv *ResultValidator) Analyze(feedback *FeedbackRequest) *ValidationResult <span class="cov0" title="0">{
        result := &amp;ValidationResult{
                IsValid:        true,
                Errors:         []string{},
                Warnings:       []string{},
                CanAutoCorrect: false,
        }

        // Apply validation rules
        for _, rule := range rv.rules </span><span class="cov0" title="0">{
                if rule.Applies(feedback) </span><span class="cov0" title="0">{
                        ruleResult := rule.Validate(feedback)
                        if !ruleResult.IsValid </span><span class="cov0" title="0">{
                                result.IsValid = false
                                result.Errors = append(result.Errors, ruleResult.Errors...)
                        }</span>
                        <span class="cov0" title="0">result.Warnings = append(result.Warnings, ruleResult.Warnings...)
                        if ruleResult.CanAutoCorrect </span><span class="cov0" title="0">{
                                result.CanAutoCorrect = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// AutoCorrector generates automatic corrections
type AutoCorrector struct {
        strategies []CorrectionStrategy
        log        *logger.Logger
}

// NewAutoCorrector creates a new auto corrector
func NewAutoCorrector() *AutoCorrector <span class="cov8" title="1">{
        return &amp;AutoCorrector{
                strategies: defaultCorrectionStrategies(),
                log:        logger.WithComponent("auto_corrector"),
        }
}</span>

// GenerateCorrection generates a correction for a validation result
func (ac *AutoCorrector) GenerateCorrection(result *ValidationResult) *Correction <span class="cov0" title="0">{
        for _, strategy := range ac.strategies </span><span class="cov0" title="0">{
                if strategy.CanHandle(result) </span><span class="cov0" title="0">{
                        return strategy.Generate(result)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// PatternLearner learns from execution patterns
type PatternLearner struct {
        patterns map[string]*Pattern
        log      *logger.Logger
}

// NewPatternLearner creates a new pattern learner
func NewPatternLearner() *PatternLearner <span class="cov8" title="1">{
        return &amp;PatternLearner{
                patterns: make(map[string]*Pattern),
                log:      logger.WithComponent("pattern_learner"),
        }
}</span>

// RecordPattern records a pattern from feedback
func (pl *PatternLearner) RecordPattern(feedback *FeedbackRequest, result *ValidationResult) <span class="cov0" title="0">{
        // Record patterns for future optimization
        patternKey := fmt.Sprintf("%s_%s", feedback.Type, feedback.SourceTask)
        
        if pattern, exists := pl.patterns[patternKey]; exists </span><span class="cov0" title="0">{
                pattern.Occurrences++
                pattern.LastSeen = time.Now()
        }</span> else<span class="cov0" title="0"> {
                pl.patterns[patternKey] = &amp;Pattern{
                        Key:         patternKey,
                        Type:        string(feedback.Type),
                        Occurrences: 1,
                        FirstSeen:   time.Now(),
                        LastSeen:    time.Now(),
                }
        }</span>
}

// Supporting types

type ValidationResult struct {
        IsValid        bool
        Errors         []string
        Warnings       []string
        CanAutoCorrect bool
        Suggestions    []string
}

type ValidationRule interface {
        Applies(feedback *FeedbackRequest) bool
        Validate(feedback *FeedbackRequest) *ValidationResult
}

type CorrectionStrategy interface {
        CanHandle(result *ValidationResult) bool
        Generate(result *ValidationResult) *Correction
}

type Correction struct {
        Type        string
        Description string
        Actions     []CorrectionAction
}

type CorrectionAction struct {
        Type   string
        Target string
        Value  interface{}
}

type Pattern struct {
        Key         string
        Type        string
        Occurrences int
        FirstSeen   time.Time
        LastSeen    time.Time
        Data        map[string]interface{}
}

// Default implementations

func defaultValidationRules() []ValidationRule <span class="cov8" title="1">{
        return []ValidationRule{
                // Add default validation rules
        }
}</span>

func defaultCorrectionStrategies() []CorrectionStrategy <span class="cov8" title="1">{
        return []CorrectionStrategy{
                // Add default correction strategies
        }
}</pre>
		
		<pre class="file" id="file8" style="display: none">package agents

import (
        "context"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/killallgit/ryan/pkg/logger"
        "github.com/killallgit/ryan/pkg/tools"
)

// FileOperationsAgent handles all file-related operations with batching and caching
type FileOperationsAgent struct {
        batchProcessor *BatchProcessor
        fileCache      *FileCache
        toolRegistry   *tools.Registry
        log            *logger.Logger
}

// NewFileOperationsAgent creates a new file operations agent
func NewFileOperationsAgent(toolRegistry *tools.Registry) *FileOperationsAgent <span class="cov0" title="0">{
        return &amp;FileOperationsAgent{
                batchProcessor: NewBatchProcessor(),
                fileCache:      NewFileCache(),
                toolRegistry:   toolRegistry,
                log:            logger.WithComponent("file_operations_agent"),
        }
}</span>

// Name returns the agent name
func (f *FileOperationsAgent) Name() string <span class="cov0" title="0">{
        return "file_operations"
}</span>

// Description returns the agent description
func (f *FileOperationsAgent) Description() string <span class="cov0" title="0">{
        return "Handles file reading, writing, creation, and batch operations with caching"
}</span>

// CanHandle determines if this agent can handle the request
func (f *FileOperationsAgent) CanHandle(request string) (bool, float64) <span class="cov0" title="0">{
        lowerRequest := strings.ToLower(request)
        
        // High confidence keywords
        highConfidenceKeywords := []string{
                "list files", "read files", "read all files",
                "create file", "write file", "update file",
                "list and read", "gather files", "file content",
        }
        
        for _, keyword := range highConfidenceKeywords </span><span class="cov0" title="0">{
                if strings.Contains(lowerRequest, keyword) </span><span class="cov0" title="0">{
                        return true, 0.9
                }</span>
        }
        
        // Medium confidence keywords
        <span class="cov0" title="0">if strings.Contains(lowerRequest, "file") || strings.Contains(lowerRequest, "directory") </span><span class="cov0" title="0">{
                return true, 0.6
        }</span>
        
        <span class="cov0" title="0">return false, 0.0</span>
}

// Execute performs file operations
func (f *FileOperationsAgent) Execute(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        startTime := time.Now()
        f.log.Info("Executing file operation", "prompt", request.Prompt)

        // Determine operation type
        operation := f.determineOperation(request.Prompt)
        
        var result AgentResult
        var err error
        
        switch operation </span>{
        case "list_and_read":<span class="cov0" title="0">
                result, err = f.handleListAndRead(ctx, request)</span>
        case "read":<span class="cov0" title="0">
                result, err = f.handleRead(ctx, request)</span>
        case "write":<span class="cov0" title="0">
                result, err = f.handleWrite(ctx, request)</span>
        case "list":<span class="cov0" title="0">
                result, err = f.handleList(ctx, request)</span>
        default:<span class="cov0" title="0">
                result = AgentResult{
                        Success: false,
                        Summary: "Unknown file operation",
                        Details: fmt.Sprintf("Could not determine operation from: %s", request.Prompt),
                }</span>
        }
        
        // Update metadata
        <span class="cov0" title="0">result.Metadata.AgentName = f.Name()
        result.Metadata.StartTime = startTime
        result.Metadata.EndTime = time.Now()
        result.Metadata.Duration = time.Since(startTime)
        
        // Update execution context if provided
        if execContext, ok := request.Context["execution_context"].(*ExecutionContext); ok </span><span class="cov0" title="0">{
                f.updateExecutionContext(execContext, result)
        }</span>
        
        <span class="cov0" title="0">return result, err</span>
}

// determineOperation determines what kind of file operation is requested
func (f *FileOperationsAgent) determineOperation(prompt string) string <span class="cov0" title="0">{
        lowerPrompt := strings.ToLower(prompt)
        
        if strings.Contains(lowerPrompt, "list and read") || 
           strings.Contains(lowerPrompt, "read all files") ||
           strings.Contains(lowerPrompt, "gather") </span><span class="cov0" title="0">{
                return "list_and_read"
        }</span>
        
        <span class="cov0" title="0">if strings.Contains(lowerPrompt, "read") </span><span class="cov0" title="0">{
                return "read"
        }</span>
        
        <span class="cov0" title="0">if strings.Contains(lowerPrompt, "write") || strings.Contains(lowerPrompt, "create") </span><span class="cov0" title="0">{
                return "write"
        }</span>
        
        <span class="cov0" title="0">if strings.Contains(lowerPrompt, "list") </span><span class="cov0" title="0">{
                return "list"
        }</span>
        
        <span class="cov0" title="0">return "unknown"</span>
}

// handleListAndRead handles listing and reading all files in a directory
func (f *FileOperationsAgent) handleListAndRead(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        // Extract directory path
        dirPath := f.extractPath(request.Prompt)
        if dirPath == "" </span><span class="cov0" title="0">{
                dirPath = "."
        }</span>
        
        <span class="cov0" title="0">f.log.Info("Listing and reading files", "directory", dirPath)
        
        // List files
        files, err := f.listFiles(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: fmt.Sprintf("Failed to list files in %s", dirPath),
                        Details: err.Error(),
                }, err
        }</span>
        
        // Read files in batch
        <span class="cov0" title="0">fileContents := make(map[string]string)
        filesProcessed := []string{}
        
        for _, file := range files </span><span class="cov0" title="0">{
                if f.shouldReadFile(file) </span><span class="cov0" title="0">{
                        content, err := f.readFileWithCache(file)
                        if err != nil </span><span class="cov0" title="0">{
                                f.log.Warn("Failed to read file", "file", file, "error", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">fileContents[file] = content
                        filesProcessed = append(filesProcessed, file)</span>
                }
        }
        
        // Build result
        <span class="cov0" title="0">details := f.buildFileListDetails(files, fileContents)
        
        return AgentResult{
                Success: true,
                Summary: fmt.Sprintf("Listed and read %d files in %s", len(filesProcessed), dirPath),
                Details: details,
                Artifacts: map[string]interface{}{
                        "files":         files,
                        "file_contents": fileContents,
                        "directory":     dirPath,
                },
                Metadata: AgentMetadata{
                        ToolsUsed:      []string{"file_list", "file_read"},
                        FilesProcessed: filesProcessed,
                },
        }, nil</span>
}

// handleRead handles reading a specific file
func (f *FileOperationsAgent) handleRead(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        filePath := f.extractPath(request.Prompt)
        if filePath == "" </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "No file path specified",
                        Details: "Please specify a file path to read",
                }, nil
        }</span>
        
        <span class="cov0" title="0">content, err := f.readFileWithCache(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: fmt.Sprintf("Failed to read file: %s", filePath),
                        Details: err.Error(),
                }, err
        }</span>
        
        <span class="cov0" title="0">return AgentResult{
                Success: true,
                Summary: fmt.Sprintf("Successfully read file: %s", filePath),
                Details: content,
                Artifacts: map[string]interface{}{
                        "file_path": filePath,
                        "content":   content,
                },
                Metadata: AgentMetadata{
                        ToolsUsed:      []string{"file_read"},
                        FilesProcessed: []string{filePath},
                },
        }, nil</span>
}

// handleWrite handles writing to a file
func (f *FileOperationsAgent) handleWrite(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        // Extract file path and content
        filePath := f.extractPath(request.Prompt)
        content := f.extractContent(request.Prompt, request.Context)
        
        if filePath == "" </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "No file path specified",
                        Details: "Please specify a file path to write to",
                }, nil
        }</span>
        
        // Use write tool
        <span class="cov0" title="0">writeTool, exists := f.toolRegistry.Get("write_file")
        if !exists </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Write tool not available",
                        Details: "The write_file tool is not registered",
                }, fmt.Errorf("write_file tool not available")
        }</span>
        
        <span class="cov0" title="0">result, err := writeTool.Execute(ctx, map[string]interface{}{
                "file_path": filePath,
                "content":   content,
        })
        
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: fmt.Sprintf("Failed to write file: %s", filePath),
                        Details: err.Error(),
                }, err
        }</span>
        
        // Invalidate cache for this file
        <span class="cov0" title="0">f.fileCache.Invalidate(filePath)
        
        return AgentResult{
                Success: true,
                Summary: fmt.Sprintf("Successfully wrote to file: %s", filePath),
                Details: result.Content,
                Artifacts: map[string]interface{}{
                        "file_path": filePath,
                        "content":   content,
                },
                Metadata: AgentMetadata{
                        ToolsUsed:      []string{"write_file"},
                        FilesProcessed: []string{filePath},
                },
        }, nil</span>
}

// handleList handles listing files in a directory
func (f *FileOperationsAgent) handleList(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        dirPath := f.extractPath(request.Prompt)
        if dirPath == "" </span><span class="cov0" title="0">{
                dirPath = "."
        }</span>
        
        <span class="cov0" title="0">files, err := f.listFiles(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: fmt.Sprintf("Failed to list files in %s", dirPath),
                        Details: err.Error(),
                }, err
        }</span>
        
        <span class="cov0" title="0">details := strings.Join(files, "\n")
        
        return AgentResult{
                Success: true,
                Summary: fmt.Sprintf("Listed %d files in %s", len(files), dirPath),
                Details: details,
                Artifacts: map[string]interface{}{
                        "files":     files,
                        "directory": dirPath,
                },
                Metadata: AgentMetadata{
                        ToolsUsed: []string{"file_list"},
                },
        }, nil</span>
}

// Helper methods

func (f *FileOperationsAgent) listFiles(dirPath string) ([]string, error) <span class="cov0" title="0">{
        var files []string
        
        err := filepath.Walk(dirPath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip files we can't access
                }</span>
                
                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        files = append(files, path)
                }</span>
                
                <span class="cov0" title="0">return nil</span>
        })
        
        <span class="cov0" title="0">return files, err</span>
}

func (f *FileOperationsAgent) readFileWithCache(filePath string) (string, error) <span class="cov0" title="0">{
        // Check cache first
        if content, ok := f.fileCache.Get(filePath); ok </span><span class="cov0" title="0">{
                return content, nil
        }</span>
        
        // Read file
        <span class="cov0" title="0">data, err := ioutil.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">content := string(data)
        
        // Cache the content
        f.fileCache.Set(filePath, content)
        
        return content, nil</span>
}

func (f *FileOperationsAgent) shouldReadFile(filePath string) bool <span class="cov0" title="0">{
        // Skip binary files, large files, etc.
        ext := strings.ToLower(filepath.Ext(filePath))
        
        // Common text file extensions
        textExts := []string{
                ".go", ".js", ".ts", ".py", ".java", ".c", ".cpp", ".h",
                ".txt", ".md", ".yml", ".yaml", ".json", ".xml", ".html",
                ".css", ".scss", ".less", ".sh", ".bash", ".zsh",
        }
        
        for _, textExt := range textExts </span><span class="cov0" title="0">{
                if ext == textExt </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Check if it's a no-extension text file (like Makefile, Dockerfile)
        <span class="cov0" title="0">base := filepath.Base(filePath)
        textFiles := []string{
                "Makefile", "Dockerfile", "README", "LICENSE",
                "Taskfile", ".gitignore", ".env",
        }
        
        for _, textFile := range textFiles </span><span class="cov0" title="0">{
                if base == textFile </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (f *FileOperationsAgent) extractPath(prompt string) string <span class="cov0" title="0">{
        // Look for quoted paths
        if start := strings.Index(prompt, "\""); start != -1 </span><span class="cov0" title="0">{
                if end := strings.Index(prompt[start+1:], "\""); end != -1 </span><span class="cov0" title="0">{
                        return prompt[start+1 : start+1+end]
                }</span>
        }
        
        // Look for paths after common keywords
        <span class="cov0" title="0">keywords := []string{" in ", " from ", " at ", " of "}
        for _, keyword := range keywords </span><span class="cov0" title="0">{
                if idx := strings.Index(prompt, keyword); idx != -1 </span><span class="cov0" title="0">{
                        pathPart := prompt[idx+len(keyword):]
                        // Take the first word/path
                        if spaceIdx := strings.IndexAny(pathPart, " ,;"); spaceIdx != -1 </span><span class="cov0" title="0">{
                                pathPart = pathPart[:spaceIdx]
                        }</span>
                        <span class="cov0" title="0">return strings.TrimSpace(pathPart)</span>
                }
        }
        
        // Look for path-like patterns
        <span class="cov0" title="0">words := strings.Fields(prompt)
        for _, word := range words </span><span class="cov0" title="0">{
                if strings.Contains(word, "/") || strings.HasSuffix(word, ".go") </span><span class="cov0" title="0">{
                        return strings.Trim(word, "\"',.")
                }</span>
        }
        
        <span class="cov0" title="0">return ""</span>
}

func (f *FileOperationsAgent) extractContent(prompt string, context map[string]interface{}) string <span class="cov0" title="0">{
        // Check if content is in context
        if content, ok := context["content"].(string); ok </span><span class="cov0" title="0">{
                return content
        }</span>
        
        // Try to extract from prompt
        <span class="cov0" title="0">patterns := []string{
                "with content:",
                "content:",
                "containing:",
        }
        
        lowerPrompt := strings.ToLower(prompt)
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if idx := strings.Index(lowerPrompt, pattern); idx != -1 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(prompt[idx+len(pattern):])
                }</span>
        }
        
        <span class="cov0" title="0">return ""</span>
}

func (f *FileOperationsAgent) buildFileListDetails(files []string, contents map[string]string) string <span class="cov0" title="0">{
        var details []string
        
        details = append(details, fmt.Sprintf("Found %d files:", len(files)))
        details = append(details, "")
        
        for _, file := range files </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("File: %s", file))
                if content, ok := contents[file]; ok </span><span class="cov0" title="0">{
                        lines := strings.Split(content, "\n")
                        preview := fmt.Sprintf("  Lines: %d", len(lines))
                        if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                                preview += fmt.Sprintf(" (First line: %s)", truncateString(lines[0], 60))
                        }</span>
                        <span class="cov0" title="0">details = append(details, preview)</span>
                }
                <span class="cov0" title="0">details = append(details, "")</span>
        }
        
        <span class="cov0" title="0">return strings.Join(details, "\n")</span>
}

func (f *FileOperationsAgent) updateExecutionContext(ctx *ExecutionContext, result AgentResult) <span class="cov0" title="0">{
        ctx.mu.Lock()
        defer ctx.mu.Unlock()
        
        // Update file context
        for _, file := range result.Metadata.FilesProcessed </span><span class="cov0" title="0">{
                found := false
                for i, fc := range ctx.FileContext </span><span class="cov0" title="0">{
                        if fc.Path == file </span><span class="cov0" title="0">{
                                ctx.FileContext[i].LastModified = time.Now()
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        ctx.FileContext = append(ctx.FileContext, FileInfo{
                                Path:         file,
                                LastModified: time.Now(),
                        })
                }</span>
        }
        
        // Store file contents in shared data
        <span class="cov0" title="0">if contents, ok := result.Artifacts["file_contents"].(map[string]string); ok </span><span class="cov0" title="0">{
                if ctx.SharedData == nil </span><span class="cov0" title="0">{
                        ctx.SharedData = make(map[string]interface{})
                }</span>
                <span class="cov0" title="0">ctx.SharedData["file_contents"] = contents</span>
        }
}

// BatchProcessor handles batch file operations
type BatchProcessor struct {
        batchSize int
}

func NewBatchProcessor() *BatchProcessor <span class="cov0" title="0">{
        return &amp;BatchProcessor{
                batchSize: 10,
        }
}</span>

// FileCache provides simple file content caching
type FileCache struct {
        cache map[string]string
        mu    sync.RWMutex
}

func NewFileCache() *FileCache <span class="cov0" title="0">{
        return &amp;FileCache{
                cache: make(map[string]string),
        }
}</span>

func (fc *FileCache) Get(path string) (string, bool) <span class="cov0" title="0">{
        fc.mu.RLock()
        defer fc.mu.RUnlock()
        content, ok := fc.cache[path]
        return content, ok
}</span>

func (fc *FileCache) Set(path string, content string) <span class="cov0" title="0">{
        fc.mu.Lock()
        defer fc.mu.Unlock()
        fc.cache[path] = content
}</span>

func (fc *FileCache) Invalidate(path string) <span class="cov0" title="0">{
        fc.mu.Lock()
        defer fc.mu.Unlock()
        delete(fc.cache, path)
}</pre>
		
		<pre class="file" id="file9" style="display: none">package agents

import (
        "context"
        
        "github.com/killallgit/ryan/pkg/models"
        "github.com/killallgit/ryan/pkg/tools"
)

// ChainType represents the type of Langchain agent chain
type ChainType string

const (
        ChainTypeReAct           ChainType = "react"
        ChainTypeOllamaFunctions ChainType = "ollama-functions"
        ChainTypeOpenAIFunctions ChainType = "openai-functions"
        ChainTypeDirect          ChainType = "direct"
)

// ModelRequirements defines the minimum model capabilities needed for an agent
type ModelRequirements struct {
        MinToolCompatibility models.ToolCompatibility
        RequiredFeatures     []string
        PreferredModels      []string
}

// LangchainAgent extends the base Agent interface with Langchain-specific capabilities
type LangchainAgent interface {
        Agent
        
        // GetChainType returns the type of chain this agent uses
        GetChainType() ChainType
        
        // GetToolCompatibility returns the list of tools this agent can use
        GetToolCompatibility() []string
        
        // GetModelRequirements returns the minimum model requirements
        GetModelRequirements() ModelRequirements
        
        // SetToolRegistry sets the tool registry for this agent
        SetToolRegistry(registry *tools.Registry)
        
        // SetModel sets the model to use for this agent
        SetModel(model string) error
        
        // SupportsStreaming indicates if this agent supports streaming responses
        SupportsStreaming() bool
}

// BaseLangchainAgent provides common functionality for all Langchain agents
type BaseLangchainAgent struct {
        name         string
        description  string
        chainType    ChainType
        toolRegistry *tools.Registry
        model        string
        requirements ModelRequirements
}

// Name returns the agent's name
func (b *BaseLangchainAgent) Name() string <span class="cov0" title="0">{
        return b.name
}</span>

// Description returns the agent's description
func (b *BaseLangchainAgent) Description() string <span class="cov0" title="0">{
        return b.description
}</span>

// GetChainType returns the chain type
func (b *BaseLangchainAgent) GetChainType() ChainType <span class="cov0" title="0">{
        return b.chainType
}</span>

// GetModelRequirements returns the model requirements
func (b *BaseLangchainAgent) GetModelRequirements() ModelRequirements <span class="cov0" title="0">{
        return b.requirements
}</span>

// SetToolRegistry sets the tool registry
func (b *BaseLangchainAgent) SetToolRegistry(registry *tools.Registry) <span class="cov0" title="0">{
        b.toolRegistry = registry
}</span>

// SetModel sets the model
func (b *BaseLangchainAgent) SetModel(model string) error <span class="cov0" title="0">{
        b.model = model
        return nil
}</span>

// SupportsStreaming returns whether streaming is supported (default: true)
func (b *BaseLangchainAgent) SupportsStreaming() bool <span class="cov0" title="0">{
        return true
}</span>

// AgentConfig contains configuration for creating agents
type AgentConfig struct {
        BaseURL      string
        Model        string
        ToolRegistry *tools.Registry
        SystemPrompt string
        Options      map[string]interface{}
}

// AgentCapability represents a specific capability an agent has
type AgentCapability string

const (
        CapabilityToolCalling     AgentCapability = "tool_calling"
        CapabilityStreaming       AgentCapability = "streaming"
        CapabilityContextWindow   AgentCapability = "context_window"
        CapabilityFunctionCalling AgentCapability = "function_calling"
        CapabilityCodeExecution   AgentCapability = "code_execution"
        CapabilityWebSearch       AgentCapability = "web_search"
        CapabilityFileOperations  AgentCapability = "file_operations"
)

// AgentMetrics tracks performance metrics for agents
type AgentMetrics struct {
        SuccessRate      float64
        AverageLatency   float64
        TokensPerRequest float64
        ErrorRate        float64
}

// AgentSelector helps select the best agent for a task
type AgentSelectorStrategy interface {
        // SelectAgent chooses the best agent for the given request
        SelectAgent(ctx context.Context, request string, available []LangchainAgent) (LangchainAgent, error)
        
        // RankAgents ranks agents by suitability for the request
        RankAgents(request string, available []LangchainAgent) []LangchainAgent
}</pre>
		
		<pre class="file" id="file10" style="display: none">package agents

import (
        "context"
        "fmt"
        "sort"
        "sync"
        
        "github.com/killallgit/ryan/pkg/logger"
        "github.com/killallgit/ryan/pkg/tools"
)

// LangchainOrchestrator orchestrates multiple Langchain agents
type LangchainOrchestrator struct {
        agents       map[string]LangchainAgent
        factory      *AgentFactory
        toolRegistry *tools.Registry
        log          *logger.Logger
        mu           sync.RWMutex
        
        // User preferences
        preferredAgent string
        fallbackChain  []string
}

// NewLangchainOrchestrator creates a new orchestrator
func NewLangchainOrchestrator(toolRegistry *tools.Registry) *LangchainOrchestrator <span class="cov0" title="0">{
        return &amp;LangchainOrchestrator{
                agents:       make(map[string]LangchainAgent),
                factory:      GlobalFactory,
                toolRegistry: toolRegistry,
                log:          logger.WithComponent("langchain_orchestrator"),
                fallbackChain: []string{"ollama-functions", "openai-functions", "conversational"},
        }
}</span>

// SetPreferredAgent sets the preferred agent type
func (o *LangchainOrchestrator) SetPreferredAgent(agentType string) error <span class="cov0" title="0">{
        if !o.factory.IsRegistered(agentType) </span><span class="cov0" title="0">{
                return fmt.Errorf("unknown agent type: %s", agentType)
        }</span>
        <span class="cov0" title="0">o.preferredAgent = agentType
        o.log.Debug("Set preferred agent", "type", agentType)
        return nil</span>
}

// SetFallbackChain sets the fallback chain for agent selection
func (o *LangchainOrchestrator) SetFallbackChain(chain []string) error <span class="cov0" title="0">{
        for _, agentType := range chain </span><span class="cov0" title="0">{
                if !o.factory.IsRegistered(agentType) </span><span class="cov0" title="0">{
                        return fmt.Errorf("unknown agent type in fallback chain: %s", agentType)
                }</span>
        }
        <span class="cov0" title="0">o.fallbackChain = chain
        return nil</span>
}

// RegisterAgent registers a pre-created agent
func (o *LangchainOrchestrator) RegisterAgent(agent LangchainAgent) error <span class="cov0" title="0">{
        o.mu.Lock()
        defer o.mu.Unlock()
        
        name := agent.Name()
        if _, exists := o.agents[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("agent %s is already registered", name)
        }</span>
        
        <span class="cov0" title="0">o.agents[name] = agent
        o.log.Debug("Registered agent", "name", name, "type", agent.GetChainType())
        return nil</span>
}

// Execute routes a request to the best available agent
func (o *LangchainOrchestrator) Execute(ctx context.Context, request string, options map[string]interface{}) (AgentResult, error) <span class="cov0" title="0">{
        // Check if a specific agent is requested in options
        if agentName, ok := options["agent"].(string); ok </span><span class="cov0" title="0">{
                return o.ExecuteWithAgent(ctx, agentName, AgentRequest{
                        Prompt:  request,
                        Options: options,
                })
        }</span>
        
        // Try to select the best agent
        <span class="cov0" title="0">agent, err := o.selectBestAgent(request, options)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{}, fmt.Errorf("failed to select agent: %w", err)
        }</span>
        
        <span class="cov0" title="0">return agent.Execute(ctx, AgentRequest{
                Prompt:  request,
                Options: options,
        })</span>
}

// ExecuteWithAgent executes with a specific agent
func (o *LangchainOrchestrator) ExecuteWithAgent(ctx context.Context, agentName string, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        o.mu.RLock()
        agent, exists := o.agents[agentName]
        o.mu.RUnlock()
        
        if !exists </span><span class="cov0" title="0">{
                // Try to create the agent on-demand
                config := AgentConfig{
                        ToolRegistry: o.toolRegistry,
                        Options:      request.Options,
                }
                
                // Extract model from options if available
                if model, ok := request.Options["model"].(string); ok </span><span class="cov0" title="0">{
                        config.Model = model
                }</span>
                
                <span class="cov0" title="0">newAgent, err := o.factory.Create(agentName, config)
                if err != nil </span><span class="cov0" title="0">{
                        return AgentResult{}, fmt.Errorf("agent %s not found and could not be created: %w", agentName, err)
                }</span>
                
                // Register the newly created agent
                <span class="cov0" title="0">if err := o.RegisterAgent(newAgent); err != nil </span><span class="cov0" title="0">{
                        o.log.Warn("Failed to register newly created agent", "error", err)
                }</span>
                
                <span class="cov0" title="0">agent = newAgent</span>
        }
        
        <span class="cov0" title="0">return agent.Execute(ctx, request)</span>
}

// ListAgents returns all registered agents
func (o *LangchainOrchestrator) ListAgents() []Agent <span class="cov0" title="0">{
        o.mu.RLock()
        defer o.mu.RUnlock()
        
        agents := make([]Agent, 0, len(o.agents))
        for _, agent := range o.agents </span><span class="cov0" title="0">{
                agents = append(agents, agent)
        }</span>
        <span class="cov0" title="0">return agents</span>
}

// ListLangchainAgents returns all registered Langchain agents
func (o *LangchainOrchestrator) ListLangchainAgents() []LangchainAgent <span class="cov0" title="0">{
        o.mu.RLock()
        defer o.mu.RUnlock()
        
        agents := make([]LangchainAgent, 0, len(o.agents))
        for _, agent := range o.agents </span><span class="cov0" title="0">{
                agents = append(agents, agent)
        }</span>
        <span class="cov0" title="0">return agents</span>
}

// selectBestAgent selects the best agent for the request
func (o *LangchainOrchestrator) selectBestAgent(request string, options map[string]interface{}) (LangchainAgent, error) <span class="cov0" title="0">{
        // If preferred agent is set, try it first
        if o.preferredAgent != "" </span><span class="cov0" title="0">{
                agent, err := o.getOrCreateAgent(o.preferredAgent, options)
                if err == nil </span><span class="cov0" title="0">{
                        canHandle, confidence := agent.CanHandle(request)
                        if canHandle &amp;&amp; confidence &gt; 0.3 </span><span class="cov0" title="0">{ // Lower threshold for preferred
                                o.log.Debug("Using preferred agent",
                                        "type", o.preferredAgent,
                                        "confidence", confidence)
                                return agent, nil
                        }</span>
                }
        }
        
        // Rank all available agents
        <span class="cov0" title="0">rankings := o.rankAgents(request)
        
        // Try agents in order of ranking
        for _, ranking := range rankings </span><span class="cov0" title="0">{
                if ranking.confidence &gt; 0.5 </span><span class="cov0" title="0">{
                        agent, err := o.getOrCreateAgent(ranking.agentName, options)
                        if err == nil </span><span class="cov0" title="0">{
                                o.log.Debug("Selected agent",
                                        "name", ranking.agentName,
                                        "confidence", ranking.confidence)
                                return agent, nil
                        }</span>
                }
        }
        
        // Fallback to the first agent in the fallback chain
        <span class="cov0" title="0">for _, agentType := range o.fallbackChain </span><span class="cov0" title="0">{
                agent, err := o.getOrCreateAgent(agentType, options)
                if err == nil </span><span class="cov0" title="0">{
                        o.log.Debug("Using fallback agent", "type", agentType)
                        return agent, nil
                }</span>
        }
        
        <span class="cov0" title="0">return nil, fmt.Errorf("no suitable agent found for request")</span>
}

// getOrCreateAgent gets an existing agent or creates a new one
func (o *LangchainOrchestrator) getOrCreateAgent(agentName string, options map[string]interface{}) (LangchainAgent, error) <span class="cov0" title="0">{
        o.mu.RLock()
        agent, exists := o.agents[agentName]
        o.mu.RUnlock()
        
        if exists </span><span class="cov0" title="0">{
                return agent, nil
        }</span>
        
        // Create the agent
        <span class="cov0" title="0">config := AgentConfig{
                ToolRegistry: o.toolRegistry,
                Options:      options,
        }
        
        if model, ok := options["model"].(string); ok </span><span class="cov0" title="0">{
                config.Model = model
        }</span>
        
        <span class="cov0" title="0">newAgent, err := o.factory.Create(agentName, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Register it for future use
        <span class="cov0" title="0">_ = o.RegisterAgent(newAgent)
        
        return newAgent, nil</span>
}

// agentRanking represents an agent's suitability ranking
type agentRanking struct {
        agentName  string
        confidence float64
}

// rankAgents ranks agents by their suitability for the request
func (o *LangchainOrchestrator) rankAgents(request string) []agentRanking <span class="cov0" title="0">{
        o.mu.RLock()
        defer o.mu.RUnlock()
        
        rankings := make([]agentRanking, 0, len(o.agents))
        
        // Check existing agents
        for name, agent := range o.agents </span><span class="cov0" title="0">{
                canHandle, confidence := agent.CanHandle(request)
                if canHandle </span><span class="cov0" title="0">{
                        rankings = append(rankings, agentRanking{
                                agentName:  name,
                                confidence: confidence,
                        })
                }</span>
        }
        
        // Also check factory-registered types that aren't instantiated yet
        <span class="cov0" title="0">for _, agentType := range o.factory.GetRegisteredTypes() </span><span class="cov0" title="0">{
                if _, exists := o.agents[agentType]; !exists </span><span class="cov0" title="0">{
                        // Estimate confidence based on agent type and request
                        // This is a simplified heuristic
                        confidence := o.estimateConfidence(agentType, request)
                        if confidence &gt; 0 </span><span class="cov0" title="0">{
                                rankings = append(rankings, agentRanking{
                                        agentName:  agentType,
                                        confidence: confidence,
                                })
                        }</span>
                }
        }
        
        // Sort by confidence (highest first)
        <span class="cov0" title="0">sort.Slice(rankings, func(i, j int) bool </span><span class="cov0" title="0">{
                return rankings[i].confidence &gt; rankings[j].confidence
        }</span>)
        
        <span class="cov0" title="0">return rankings</span>
}

// estimateConfidence estimates confidence for an uninstantiated agent type
func (o *LangchainOrchestrator) estimateConfidence(agentType, request string) float64 <span class="cov0" title="0">{
        // Simple heuristic based on agent type
        switch agentType </span>{
        case "ollama-functions":<span class="cov0" title="0">
                if o.toolRegistry != nil &amp;&amp; o.toolRegistry.HasTools() </span><span class="cov0" title="0">{
                        return 0.7
                }</span>
                <span class="cov0" title="0">return 0.3</span>
        case "openai-functions":<span class="cov0" title="0">
                if o.toolRegistry != nil &amp;&amp; o.toolRegistry.HasTools() </span><span class="cov0" title="0">{
                        return 0.6
                }</span>
                <span class="cov0" title="0">return 0.3</span>
        case "conversational", "react":<span class="cov0" title="0">
                return 0.5</span> // Can handle most things reasonably
        default:<span class="cov0" title="0">
                return 0.2</span>
        }
}</pre>
		
		<pre class="file" id="file11" style="display: none">package agents

import (
        "context"
        "fmt"
        "strings"
        
        "github.com/killallgit/ryan/pkg/langchain"
        "github.com/killallgit/ryan/pkg/logger"
        "github.com/killallgit/ryan/pkg/models"
)

// OllamaFunctionsAgent implements native Ollama function calling
type OllamaFunctionsAgent struct {
        BaseLangchainAgent
        client *langchain.Client
        log    *logger.Logger
}

// NewOllamaFunctionsAgent creates a new Ollama functions agent
func NewOllamaFunctionsAgent(config AgentConfig) (LangchainAgent, error) <span class="cov0" title="0">{
        // Verify the model supports Ollama functions
        if !isOllamaCompatibleModel(config.Model) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("model %s is not compatible with Ollama functions", config.Model)
        }</span>
        
        <span class="cov0" title="0">client, err := langchain.NewClient(config.BaseURL, config.Model, config.ToolRegistry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create langchain client: %w", err)
        }</span>
        
        <span class="cov0" title="0">agent := &amp;OllamaFunctionsAgent{
                BaseLangchainAgent: BaseLangchainAgent{
                        name:         "ollama-functions",
                        description:  "Native Ollama function calling for efficient tool usage",
                        chainType:    ChainTypeOllamaFunctions,
                        toolRegistry: config.ToolRegistry,
                        model:        config.Model,
                        requirements: ModelRequirements{
                                MinToolCompatibility: models.ToolCompatibilityExcellent,
                                RequiredFeatures:     []string{"function_calling", "ollama_compatible"},
                                PreferredModels:      []string{"llama3.1", "qwen2.5", "mistral", "deepseek", "command-r"},
                        },
                },
                client: client,
                log:    logger.WithComponent("ollama_functions_agent"),
        }
        
        return agent, nil</span>
}

// CanHandle determines if this agent can handle the request
func (o *OllamaFunctionsAgent) CanHandle(request string) (bool, float64) <span class="cov0" title="0">{
        // Check if model is Ollama compatible
        if !isOllamaCompatibleModel(o.model) </span><span class="cov0" title="0">{
                return false, 0.0
        }</span>
        
        // High confidence for tool-heavy tasks
        <span class="cov0" title="0">lowerRequest := strings.ToLower(request)
        
        toolKeywords := []string{
                "run", "execute", "create", "delete", "list", "show",
                "grep", "search", "find", "fetch", "download",
        }
        
        keywordCount := 0
        for _, keyword := range toolKeywords </span><span class="cov0" title="0">{
                if strings.Contains(lowerRequest, keyword) </span><span class="cov0" title="0">{
                        keywordCount++
                }</span>
        }
        
        <span class="cov0" title="0">if keywordCount &gt; 0 </span><span class="cov0" title="0">{
                confidence := 0.7 + float64(keywordCount)*0.1
                if confidence &gt; 1.0 </span><span class="cov0" title="0">{
                        confidence = 1.0
                }</span>
                <span class="cov0" title="0">return true, confidence</span>
        }
        
        // Medium confidence if tools are available
        <span class="cov0" title="0">if o.toolRegistry != nil &amp;&amp; o.toolRegistry.HasTools() </span><span class="cov0" title="0">{
                return true, 0.6
        }</span>
        
        <span class="cov0" title="0">return false, 0.0</span>
}

// Execute performs the agent's task using Ollama function calling
func (o *OllamaFunctionsAgent) Execute(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        o.log.Debug("Executing Ollama functions agent",
                "prompt", request.Prompt,
                "model", o.model,
                "tools_available", o.toolRegistry != nil)
        
        // Configure client for Ollama function mode
        if o.client != nil </span>{<span class="cov0" title="0">
                // This would set the agent type in the client
                // The client would handle the specific Ollama function calling protocol
        }</span>
        
        <span class="cov0" title="0">response, err := o.client.SendMessage(ctx, request.Prompt)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Failed to execute Ollama functions agent",
                        Details: err.Error(),
                }, err
        }</span>
        
        <span class="cov0" title="0">return AgentResult{
                Success: true,
                Summary: "Ollama functions agent completed successfully",
                Details: response,
                Metadata: AgentMetadata{
                        AgentName: o.name,
                },
        }, nil</span>
}

// GetToolCompatibility returns tools this agent can use
func (o *OllamaFunctionsAgent) GetToolCompatibility() []string <span class="cov0" title="0">{
        if o.toolRegistry == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        
        <span class="cov0" title="0">tools := o.toolRegistry.GetTools()
        toolNames := make([]string, 0, len(tools))
        for _, tool := range tools </span><span class="cov0" title="0">{
                toolNames = append(toolNames, tool.Name())
        }</span>
        <span class="cov0" title="0">return toolNames</span>
}

// isOllamaCompatibleModel checks if a model supports Ollama function calling
func isOllamaCompatibleModel(model string) bool <span class="cov0" title="0">{
        ollamaModels := []string{
                "llama", "qwen", "mistral", "deepseek", "command-r",
                "granite", "gemma2", "phi3",
        }
        
        modelLower := strings.ToLower(model)
        for _, compatible := range ollamaModels </span><span class="cov0" title="0">{
                if strings.Contains(modelLower, compatible) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package agents

import (
        "context"
        "fmt"
        "strings"
        
        "github.com/killallgit/ryan/pkg/langchain"
        "github.com/killallgit/ryan/pkg/logger"
        "github.com/killallgit/ryan/pkg/models"
)

// OpenAIFunctionsAgent implements OpenAI-style function calling
type OpenAIFunctionsAgent struct {
        BaseLangchainAgent
        client *langchain.Client
        log    *logger.Logger
}

// NewOpenAIFunctionsAgent creates a new OpenAI functions agent
func NewOpenAIFunctionsAgent(config AgentConfig) (LangchainAgent, error) <span class="cov0" title="0">{
        // Verify the model supports OpenAI functions
        if !isOpenAICompatibleModel(config.Model) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("model %s is not compatible with OpenAI functions", config.Model)
        }</span>
        
        <span class="cov0" title="0">client, err := langchain.NewClient(config.BaseURL, config.Model, config.ToolRegistry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create langchain client: %w", err)
        }</span>
        
        <span class="cov0" title="0">agent := &amp;OpenAIFunctionsAgent{
                BaseLangchainAgent: BaseLangchainAgent{
                        name:         "openai-functions",
                        description:  "OpenAI-style function calling for structured tool usage",
                        chainType:    ChainTypeOpenAIFunctions,
                        toolRegistry: config.ToolRegistry,
                        model:        config.Model,
                        requirements: ModelRequirements{
                                MinToolCompatibility: models.ToolCompatibilityExcellent,
                                RequiredFeatures:     []string{"function_calling", "openai_compatible"},
                                PreferredModels:      []string{"gpt-4", "gpt-4-turbo", "gpt-3.5-turbo", "claude-3"},
                        },
                },
                client: client,
                log:    logger.WithComponent("openai_functions_agent"),
        }
        
        return agent, nil</span>
}

// CanHandle determines if this agent can handle the request
func (o *OpenAIFunctionsAgent) CanHandle(request string) (bool, float64) <span class="cov0" title="0">{
        // Check if model is OpenAI compatible
        if !isOpenAICompatibleModel(o.model) </span><span class="cov0" title="0">{
                return false, 0.0
        }</span>
        
        // High confidence for structured tasks
        <span class="cov0" title="0">lowerRequest := strings.ToLower(request)
        
        // OpenAI functions excel at structured operations
        if strings.Contains(lowerRequest, "api") ||
                strings.Contains(lowerRequest, "function") ||
                strings.Contains(lowerRequest, "structured") ||
                strings.Contains(lowerRequest, "json") </span><span class="cov0" title="0">{
                return true, 0.95
        }</span>
        
        // Good for general tool usage
        <span class="cov0" title="0">if o.toolRegistry != nil &amp;&amp; o.toolRegistry.HasTools() </span><span class="cov0" title="0">{
                return true, 0.8
        }</span>
        
        <span class="cov0" title="0">return true, 0.5</span>
}

// Execute performs the agent's task using OpenAI function calling
func (o *OpenAIFunctionsAgent) Execute(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov0" title="0">{
        o.log.Debug("Executing OpenAI functions agent",
                "prompt", request.Prompt,
                "model", o.model,
                "tools_available", o.toolRegistry != nil)
        
        response, err := o.client.SendMessage(ctx, request.Prompt)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Failed to execute OpenAI functions agent",
                        Details: err.Error(),
                }, err
        }</span>
        
        <span class="cov0" title="0">return AgentResult{
                Success: true,
                Summary: "OpenAI functions agent completed successfully",
                Details: response,
                Metadata: AgentMetadata{
                        AgentName: o.name,
                },
        }, nil</span>
}

// GetToolCompatibility returns tools this agent can use
func (o *OpenAIFunctionsAgent) GetToolCompatibility() []string <span class="cov0" title="0">{
        if o.toolRegistry == nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        
        <span class="cov0" title="0">tools := o.toolRegistry.GetTools()
        toolNames := make([]string, 0, len(tools))
        for _, tool := range tools </span><span class="cov0" title="0">{
                toolNames = append(toolNames, tool.Name())
        }</span>
        <span class="cov0" title="0">return toolNames</span>
}

// isOpenAICompatibleModel checks if a model supports OpenAI function calling
func isOpenAICompatibleModel(model string) bool <span class="cov0" title="0">{
        openAIModels := []string{
                "gpt-4", "gpt-3.5", "claude", "gemini",
        }
        
        modelLower := strings.ToLower(model)
        for _, compatible := range openAIModels </span><span class="cov0" title="0">{
                if strings.Contains(modelLower, compatible) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package agents

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/killallgit/ryan/pkg/logger"
        "github.com/killallgit/ryan/pkg/tools"
)

// Orchestrator coordinates agent execution with advanced planning and feedback loops
type Orchestrator struct {
        agents         map[string]Agent
        executor       *Executor
        contextManager *ContextManager
        planner        *Planner
        feedbackLoop   *FeedbackLoop
        log            *logger.Logger
        mu             sync.RWMutex
}

// NewOrchestrator creates a new agent orchestrator
func NewOrchestrator() *Orchestrator <span class="cov8" title="1">{
        o := &amp;Orchestrator{
                agents:         make(map[string]Agent),
                executor:       NewExecutor(),
                contextManager: NewContextManager(),
                planner:        NewPlanner(),
                feedbackLoop:   NewFeedbackLoop(),
                log:            logger.WithComponent("orchestrator"),
        }
        
        // Set up circular references
        o.executor.SetOrchestrator(o)
        o.planner.SetOrchestrator(o)
        o.feedbackLoop.SetOrchestrator(o)
        
        // Register built-in dispatcher agent
        dispatcher := NewDispatcherAgent(o)
        o.RegisterAgent(dispatcher)
        
        return o
}</span>

// RegisterBuiltinAgents registers all built-in agents
func (o *Orchestrator) RegisterBuiltinAgents(toolRegistry *tools.Registry) error <span class="cov0" title="0">{
        // Register file operations agent
        fileOpsAgent := NewFileOperationsAgent(toolRegistry)
        if err := o.RegisterAgent(fileOpsAgent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register file operations agent: %w", err)
        }</span>

        // Register code analysis agent
        <span class="cov0" title="0">codeAnalysisAgent := NewCodeAnalysisAgent()
        if err := o.RegisterAgent(codeAnalysisAgent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register code analysis agent: %w", err)
        }</span>

        // Register code review agent
        <span class="cov0" title="0">codeReviewAgent := NewCodeReviewAgent()
        if err := o.RegisterAgent(codeReviewAgent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register code review agent: %w", err)
        }</span>

        // Register search agent
        <span class="cov0" title="0">searchAgent := NewSearchAgent(toolRegistry)
        if err := o.RegisterAgent(searchAgent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register search agent: %w", err)
        }</span>

        <span class="cov0" title="0">o.log.Info("Registered built-in agents", "count", 5) // dispatcher + 4 agents
        return nil</span>
}

// RegisterAgent registers an agent with the orchestrator
func (o *Orchestrator) RegisterAgent(agent Agent) error <span class="cov8" title="1">{
        o.mu.Lock()
        defer o.mu.Unlock()

        name := agent.Name()
        if _, exists := o.agents[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("agent %s already registered", name)
        }</span>

        <span class="cov8" title="1">o.agents[name] = agent
        o.log.Info("Registered agent", "name", name, "description", agent.Description())
        return nil</span>
}

// Execute analyzes the request and orchestrates agent execution
func (o *Orchestrator) Execute(ctx context.Context, request string, options map[string]interface{}) (AgentResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        o.log.Info("Executing request", "request_preview", truncateString(request, 100))

        // Create execution context
        execContext := &amp;ExecutionContext{
                SessionID:   generateID(),
                RequestID:   generateID(),
                UserPrompt:  request,
                SharedData:  make(map[string]interface{}),
                FileContext: []FileInfo{},
                Progress:    make(chan ProgressUpdate, 100),
                Options:     options,
        }

        // Plan the execution
        plan, err := o.planner.CreateExecutionPlan(ctx, request, execContext)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Failed to create execution plan",
                        Details: err.Error(),
                        Metadata: AgentMetadata{
                                StartTime: startTime,
                                EndTime:   time.Now(),
                                Duration:  time.Since(startTime),
                        },
                }, err
        }</span>

        <span class="cov8" title="1">o.log.Info("Created execution plan", "tasks", len(plan.Tasks), "stages", len(plan.Stages))

        // Execute the plan
        results, err := o.executor.ExecutePlan(ctx, plan, execContext)
        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Execution failed",
                        Details: err.Error(),
                        Metadata: AgentMetadata{
                                StartTime: startTime,
                                EndTime:   time.Now(),
                                Duration:  time.Since(startTime),
                        },
                }, err
        }</span>

        // Aggregate results
        <span class="cov8" title="1">finalResult := o.aggregateResults(results, plan, execContext)
        finalResult.Metadata.StartTime = startTime
        finalResult.Metadata.EndTime = time.Now()
        finalResult.Metadata.Duration = time.Since(startTime)

        return finalResult, nil</span>
}

// ExecuteWithPlan executes a pre-built execution plan
func (o *Orchestrator) ExecuteWithPlan(ctx context.Context, plan *ExecutionPlan, execContext *ExecutionContext) ([]TaskResult, error) <span class="cov0" title="0">{
        return o.executor.ExecutePlan(ctx, plan, execContext)
}</span>

// GetAgent retrieves a registered agent by name
func (o *Orchestrator) GetAgent(name string) (Agent, error) <span class="cov8" title="1">{
        o.mu.RLock()
        defer o.mu.RUnlock()

        agent, exists := o.agents[name]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("agent %s not found", name)
        }</span>
        <span class="cov8" title="1">return agent, nil</span>
}

// ListAgents returns all registered agents
func (o *Orchestrator) ListAgents() []Agent <span class="cov8" title="1">{
        o.mu.RLock()
        defer o.mu.RUnlock()

        agents := make([]Agent, 0, len(o.agents))
        for _, agent := range o.agents </span><span class="cov8" title="1">{
                agents = append(agents, agent)
        }</span>
        <span class="cov8" title="1">return agents</span>
}

// ProcessFeedback handles feedback from agent execution
func (o *Orchestrator) ProcessFeedback(ctx context.Context, feedback *FeedbackRequest) error <span class="cov0" title="0">{
        return o.feedbackLoop.ProcessFeedback(ctx, feedback)
}</span>

// aggregateResults combines multiple task results into a final result
func (o *Orchestrator) aggregateResults(results []TaskResult, plan *ExecutionPlan, ctx *ExecutionContext) AgentResult <span class="cov8" title="1">{
        // Check if all tasks succeeded
        allSuccess := true
        var failedTasks []string
        var successfulTasks []string
        var allDetails []string
        var toolsUsed []string
        var filesProcessed []string
        toolsMap := make(map[string]bool)
        filesMap := make(map[string]bool)

        for _, result := range results </span><span class="cov8" title="1">{
                if !result.Result.Success </span><span class="cov0" title="0">{
                        allSuccess = false
                        failedTasks = append(failedTasks, result.Task.ID)
                }</span> else<span class="cov8" title="1"> {
                        successfulTasks = append(successfulTasks, result.Task.ID)
                }</span>
                
                // Collect details
                <span class="cov8" title="1">if result.Result.Details != "" </span><span class="cov8" title="1">{
                        allDetails = append(allDetails, fmt.Sprintf("[%s]: %s", result.Task.Agent, result.Result.Details))
                }</span>
                
                // Collect unique tools and files
                <span class="cov8" title="1">for _, tool := range result.Result.Metadata.ToolsUsed </span><span class="cov0" title="0">{
                        toolsMap[tool] = true
                }</span>
                <span class="cov8" title="1">for _, file := range result.Result.Metadata.FilesProcessed </span><span class="cov0" title="0">{
                        filesMap[file] = true
                }</span>
        }

        // Convert maps to slices
        <span class="cov8" title="1">for tool := range toolsMap </span><span class="cov0" title="0">{
                toolsUsed = append(toolsUsed, tool)
        }</span>
        <span class="cov8" title="1">for file := range filesMap </span><span class="cov0" title="0">{
                filesProcessed = append(filesProcessed, file)
        }</span>

        // Build summary
        <span class="cov8" title="1">summary := fmt.Sprintf("Executed %d tasks (%d successful, %d failed)", 
                len(results), len(successfulTasks), len(failedTasks))

        // Combine all details
        details := ""
        if len(allDetails) &gt; 0 </span><span class="cov8" title="1">{
                details = joinStrings(allDetails, "\n\n")
        }</span>

        // Create artifacts map from context
        <span class="cov8" title="1">artifacts := make(map[string]interface{})
        if ctx.SharedData != nil </span><span class="cov8" title="1">{
                artifacts["shared_data"] = ctx.SharedData
        }</span>
        <span class="cov8" title="1">if len(ctx.FileContext) &gt; 0 </span><span class="cov0" title="0">{
                artifacts["files"] = ctx.FileContext
        }</span>

        <span class="cov8" title="1">return AgentResult{
                Success: allSuccess,
                Summary: summary,
                Details: details,
                Artifacts: artifacts,
                Metadata: AgentMetadata{
                        ToolsUsed:      toolsUsed,
                        FilesProcessed: filesProcessed,
                },
        }</span>
}

// Helper functions

func joinStrings(strings []string, separator string) string <span class="cov8" title="1">{
        result := ""
        for i, s := range strings </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += separator
                }</span>
                <span class="cov8" title="1">result += s</span>
        }
        <span class="cov8" title="1">return result</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package agents

import (
        "context"
        "fmt"
        "strings"

        "github.com/killallgit/ryan/pkg/logger"
)

// Planner analyzes user prompts and creates execution plans
type Planner struct {
        orchestrator    *Orchestrator
        intentAnalyzer  *IntentAnalyzer
        graphBuilder    *ExecutionGraphBuilder
        optimizer       *PlanOptimizer
        log             *logger.Logger
}

// NewPlanner creates a new execution planner
func NewPlanner() *Planner <span class="cov8" title="1">{
        return &amp;Planner{
                intentAnalyzer:  NewIntentAnalyzer(),
                graphBuilder:    NewExecutionGraphBuilder(),
                optimizer:       NewPlanOptimizer(),
                log:             logger.WithComponent("planner"),
        }
}</span>

// SetOrchestrator sets the orchestrator reference
func (p *Planner) SetOrchestrator(o *Orchestrator) <span class="cov8" title="1">{
        p.orchestrator = o
}</span>

// CreateExecutionPlan analyzes the request and creates an optimized execution plan
func (p *Planner) CreateExecutionPlan(ctx context.Context, request string, execContext *ExecutionContext) (*ExecutionPlan, error) <span class="cov8" title="1">{
        p.log.Info("Creating execution plan", "request_preview", truncateString(request, 100))

        // Validate request
        if strings.TrimSpace(request) == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("empty request")
        }</span>

        // Validate orchestrator is set
        <span class="cov8" title="1">if p.orchestrator == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("orchestrator not set")
        }</span>

        // Analyze intent
        <span class="cov8" title="1">intent, err := p.intentAnalyzer.Analyze(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to analyze intent: %w", err)
        }</span>

        <span class="cov8" title="1">p.log.Debug("Analyzed intent", "primary", intent.Primary, "secondary", intent.Secondary)

        // Build initial execution graph
        graph, err := p.graphBuilder.BuildGraph(intent, p.orchestrator)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build execution graph: %w", err)
        }</span>

        // Optimize the plan
        <span class="cov8" title="1">plan := p.optimizer.Optimize(graph, execContext)

        p.log.Info("Created execution plan", 
                "tasks", len(plan.Tasks),
                "stages", len(plan.Stages),
                "estimated_duration", plan.EstimatedDuration)

        return plan, nil</span>
}

// IntentAnalyzer analyzes user prompts to determine intent
type IntentAnalyzer struct {
        patterns []IntentPattern
        log      *logger.Logger
}

// NewIntentAnalyzer creates a new intent analyzer
func NewIntentAnalyzer() *IntentAnalyzer <span class="cov8" title="1">{
        return &amp;IntentAnalyzer{
                patterns: defaultIntentPatterns(),
                log:      logger.WithComponent("intent_analyzer"),
        }
}</span>

// Analyze extracts intent from a user prompt
func (ia *IntentAnalyzer) Analyze(prompt string) (*Intent, error) <span class="cov8" title="1">{
        lowerPrompt := strings.ToLower(prompt)
        
        intent := &amp;Intent{
                RawPrompt: prompt,
                Entities:  make(map[string]string),
        }

        // Match against patterns
        for _, pattern := range ia.patterns </span><span class="cov8" title="1">{
                if pattern.Matches(lowerPrompt) </span><span class="cov8" title="1">{
                        intent.Primary = pattern.IntentType
                        intent.Confidence = pattern.GetConfidence(lowerPrompt)
                        
                        // Extract entities
                        entities := pattern.ExtractEntities(prompt)
                        for k, v := range entities </span><span class="cov0" title="0">{
                                intent.Entities[k] = v
                        }</span>
                        
                        <span class="cov8" title="1">break</span>
                }
        }

        // If no primary intent found, use generic
        <span class="cov8" title="1">if intent.Primary == "" </span><span class="cov8" title="1">{
                intent.Primary = IntentGeneric
                intent.Confidence = 0.5
        }</span>

        // Look for secondary intents
        <span class="cov8" title="1">intent.Secondary = ia.findSecondaryIntents(lowerPrompt)

        return intent, nil</span>
}

// findSecondaryIntents identifies additional intents in the prompt
func (ia *IntentAnalyzer) findSecondaryIntents(prompt string) []string <span class="cov8" title="1">{
        var secondary []string
        
        // Check for common secondary patterns
        if strings.Contains(prompt, "and test") || strings.Contains(prompt, "with tests") </span><span class="cov0" title="0">{
                secondary = append(secondary, "test")
        }</span>
        <span class="cov8" title="1">if strings.Contains(prompt, "document") || strings.Contains(prompt, "with docs") </span><span class="cov0" title="0">{
                secondary = append(secondary, "document")
        }</span>
        <span class="cov8" title="1">if strings.Contains(prompt, "optimize") || strings.Contains(prompt, "performance") </span><span class="cov0" title="0">{
                secondary = append(secondary, "optimize")
        }</span>
        <span class="cov8" title="1">if strings.Contains(prompt, "and fix") || strings.Contains(prompt, "fix them") </span><span class="cov8" title="1">{
                secondary = append(secondary, "fix")
        }</span>
        <span class="cov8" title="1">if strings.Contains(prompt, "and analyze") || strings.Contains(prompt, "analyze") </span><span class="cov8" title="1">{
                secondary = append(secondary, "analyze")
        }</span>
        
        <span class="cov8" title="1">return secondary</span>
}

// ExecutionGraphBuilder builds execution graphs from intents
type ExecutionGraphBuilder struct {
        templates map[string]*PlanTemplate
        log       *logger.Logger
}

// NewExecutionGraphBuilder creates a new graph builder
func NewExecutionGraphBuilder() *ExecutionGraphBuilder <span class="cov8" title="1">{
        return &amp;ExecutionGraphBuilder{
                templates: defaultPlanTemplates(),
                log:       logger.WithComponent("graph_builder"),
        }
}</span>

// BuildGraph creates an execution graph from an intent
func (gb *ExecutionGraphBuilder) BuildGraph(intent *Intent, orchestrator *Orchestrator) (*ExecutionGraph, error) <span class="cov8" title="1">{
        // Find matching template
        template, exists := gb.templates[string(intent.Primary)]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no template for intent: %s", intent.Primary)
        }</span>

        // Create graph from template
        <span class="cov8" title="1">graph := &amp;ExecutionGraph{
                Nodes: make(map[string]*GraphNode),
                Edges: make(map[string][]string),
        }

        // Build nodes
        for _, taskTemplate := range template.Tasks </span><span class="cov8" title="1">{
                agent, err := orchestrator.GetAgent(taskTemplate.Agent)
                if err != nil </span><span class="cov0" title="0">{
                        gb.log.Warn("Agent not found, skipping", "agent", taskTemplate.Agent)
                        continue</span>
                }

                <span class="cov8" title="1">node := &amp;GraphNode{
                        ID:           generateID(),
                        Agent:        taskTemplate.Agent,
                        AgentRef:     agent,
                        Priority:     taskTemplate.Priority,
                        Dependencies: taskTemplate.Dependencies,
                        Request: AgentRequest{
                                Prompt:  gb.buildPromptForTask(&amp;taskTemplate, intent),
                                Context: make(map[string]interface{}),
                        },
                }

                graph.Nodes[node.ID] = node
                
                // Build edges based on dependencies
                for _, dep := range taskTemplate.Dependencies </span><span class="cov0" title="0">{
                        graph.Edges[dep] = append(graph.Edges[dep], node.ID)
                }</span>
        }

        <span class="cov8" title="1">return graph, nil</span>
}

// buildPromptForTask creates a specific prompt for a task based on intent
func (gb *ExecutionGraphBuilder) buildPromptForTask(task *TaskTemplate, intent *Intent) string <span class="cov8" title="1">{
        prompt := task.PromptTemplate
        
        // Replace raw_prompt placeholder
        prompt = strings.ReplaceAll(prompt, "{raw_prompt}", intent.RawPrompt)
        
        // Replace placeholders with entities
        for key, value := range intent.Entities </span><span class="cov8" title="1">{
                placeholder := fmt.Sprintf("{%s}", key)
                prompt = strings.ReplaceAll(prompt, placeholder, value)
        }</span>
        
        <span class="cov8" title="1">return prompt</span>
}

// PlanOptimizer optimizes execution plans
type PlanOptimizer struct {
        log *logger.Logger
}

// NewPlanOptimizer creates a new plan optimizer
func NewPlanOptimizer() *PlanOptimizer <span class="cov8" title="1">{
        return &amp;PlanOptimizer{
                log: logger.WithComponent("plan_optimizer"),
        }
}</span>

// Optimize converts a graph into an optimized execution plan
func (po *PlanOptimizer) Optimize(graph *ExecutionGraph, context *ExecutionContext) *ExecutionPlan <span class="cov8" title="1">{
        plan := &amp;ExecutionPlan{
                ID:        generateID(),
                Context:   context,
                Tasks:     make([]Task, 0),
                Stages:    make([]Stage, 0),
        }

        // Topological sort to determine execution order
        stages := po.topologicalSort(graph)
        
        // Create stages
        for i, nodeIDs := range stages </span><span class="cov8" title="1">{
                stage := Stage{
                        ID:    fmt.Sprintf("stage-%d", i),
                        Tasks: make([]string, 0),
                }
                
                // Create tasks for this stage
                for _, nodeID := range nodeIDs </span><span class="cov8" title="1">{
                        node := graph.Nodes[nodeID]
                        task := Task{
                                ID:           nodeID,
                                Agent:        node.Agent,
                                Request:      node.Request,
                                Priority:     node.Priority,
                                Dependencies: node.Dependencies,
                                Stage:        stage.ID,
                        }
                        
                        plan.Tasks = append(plan.Tasks, task)
                        stage.Tasks = append(stage.Tasks, task.ID)
                }</span>
                
                <span class="cov8" title="1">plan.Stages = append(plan.Stages, stage)</span>
        }

        // Estimate duration
        <span class="cov8" title="1">plan.EstimatedDuration = po.estimateDuration(plan)

        return plan</span>
}

// topologicalSort performs topological sorting on the graph
func (po *PlanOptimizer) topologicalSort(graph *ExecutionGraph) [][]string <span class="cov8" title="1">{
        // Simple level-based topological sort
        levels := make([][]string, 0)
        visited := make(map[string]bool)
        
        // Find nodes with no dependencies
        for </span><span class="cov8" title="1">{
                level := make([]string, 0)
                
                for nodeID, node := range graph.Nodes </span><span class="cov8" title="1">{
                        if visited[nodeID] </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        
                        // Check if all dependencies are satisfied
                        <span class="cov8" title="1">canExecute := true
                        for _, dep := range node.Dependencies </span><span class="cov8" title="1">{
                                if !visited[dep] </span><span class="cov8" title="1">{
                                        canExecute = false
                                        break</span>
                                }
                        }
                        
                        <span class="cov8" title="1">if canExecute </span><span class="cov8" title="1">{
                                level = append(level, nodeID)
                        }</span>
                }
                
                <span class="cov8" title="1">if len(level) == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                
                // Mark as visited
                <span class="cov8" title="1">for _, nodeID := range level </span><span class="cov8" title="1">{
                        visited[nodeID] = true
                }</span>
                
                <span class="cov8" title="1">levels = append(levels, level)</span>
        }
        
        <span class="cov8" title="1">return levels</span>
}

// estimateDuration estimates the total duration of a plan
func (po *PlanOptimizer) estimateDuration(plan *ExecutionPlan) string <span class="cov8" title="1">{
        // Simple estimation: 2 seconds per task + 1 second per stage
        totalSeconds := len(plan.Tasks)*2 + len(plan.Stages)
        return fmt.Sprintf("%ds", totalSeconds)
}</span>

// Types for intent analysis

type IntentType string

const (
        IntentCodeReview    IntentType = "code_review"
        IntentFileOperation IntentType = "file_operation"
        IntentSearch        IntentType = "search"
        IntentAnalysis      IntentType = "analysis"
        IntentRefactor      IntentType = "refactor"
        IntentTest          IntentType = "test"
        IntentGeneric       IntentType = "generic"
)

type Intent struct {
        Primary    IntentType
        Secondary  []string
        RawPrompt  string
        Entities   map[string]string
        Confidence float64
}

type IntentPattern struct {
        Pattern    string
        IntentType IntentType
        Extract    []string
}

func (ip *IntentPattern) Matches(prompt string) bool <span class="cov8" title="1">{
        return strings.Contains(prompt, ip.Pattern)
}</span>

func (ip *IntentPattern) GetConfidence(prompt string) float64 <span class="cov8" title="1">{
        // Simple confidence based on pattern match
        if strings.Contains(prompt, ip.Pattern) </span><span class="cov8" title="1">{
                return 0.8
        }</span>
        <span class="cov0" title="0">return 0.0</span>
}

func (ip *IntentPattern) ExtractEntities(prompt string) map[string]string <span class="cov8" title="1">{
        entities := make(map[string]string)
        
        // Simple entity extraction - would be more sophisticated in practice
        for _, extract := range ip.Extract </span><span class="cov8" title="1">{
                switch extract </span>{
                case "path":<span class="cov8" title="1">
                        // Extract file paths
                        words := strings.Fields(prompt)
                        for _, word := range words </span><span class="cov8" title="1">{
                                if strings.Contains(word, "/") || strings.HasSuffix(word, ".go") </span><span class="cov0" title="0">{
                                        entities["path"] = strings.Trim(word, "\"',.")
                                        break</span>
                                }
                        }
                case "target":<span class="cov8" title="1">
                        // Extract target for operations
                        if idx := strings.Index(prompt, " of "); idx != -1 </span><span class="cov0" title="0">{
                                target := prompt[idx+4:]
                                if endIdx := strings.IndexAny(target, " ,;"); endIdx != -1 </span><span class="cov0" title="0">{
                                        target = target[:endIdx]
                                }</span>
                                <span class="cov0" title="0">entities["target"] = strings.TrimSpace(target)</span>
                        }
                }
        }
        
        <span class="cov8" title="1">return entities</span>
}

// Default patterns and templates

func defaultIntentPatterns() []IntentPattern <span class="cov8" title="1">{
        return []IntentPattern{
                {Pattern: "code review", IntentType: IntentCodeReview, Extract: []string{"target", "path"}},
                {Pattern: "review", IntentType: IntentCodeReview, Extract: []string{"target", "path"}},
                {Pattern: "analyze", IntentType: IntentAnalysis, Extract: []string{"target", "path"}},
                {Pattern: "create file", IntentType: IntentFileOperation, Extract: []string{"path"}},
                {Pattern: "read file", IntentType: IntentFileOperation, Extract: []string{"path"}},
                {Pattern: "search for", IntentType: IntentSearch, Extract: []string{"target"}},
                {Pattern: "find", IntentType: IntentSearch, Extract: []string{"target"}},
                {Pattern: "refactor", IntentType: IntentRefactor, Extract: []string{"target", "path"}},
                {Pattern: "test", IntentType: IntentTest, Extract: []string{"target", "path"}},
        }
}</span>

type TaskTemplate struct {
        Agent          string
        PromptTemplate string
        Priority       int
        Dependencies   []string
}

type PlanTemplate struct {
        Intent IntentType
        Tasks  []TaskTemplate
}

func defaultPlanTemplates() map[string]*PlanTemplate <span class="cov8" title="1">{
        return map[string]*PlanTemplate{
                string(IntentCodeReview): {
                        Intent: IntentCodeReview,
                        Tasks: []TaskTemplate{
                                {
                                        Agent:          "file_operations",
                                        PromptTemplate: "List and read all files in {target}",
                                        Priority:       1,
                                        Dependencies:   []string{},
                                },
                                {
                                        Agent:          "code_analysis",
                                        PromptTemplate: "Analyze code structure and patterns in {target}",
                                        Priority:       2,
                                        Dependencies:   []string{},
                                },
                                {
                                        Agent:          "code_review",
                                        PromptTemplate: "Perform comprehensive code review of {target}",
                                        Priority:       3,
                                        Dependencies:   []string{},
                                },
                        },
                },
                string(IntentFileOperation): {
                        Intent: IntentFileOperation,
                        Tasks: []TaskTemplate{
                                {
                                        Agent:          "file_operations",
                                        PromptTemplate: "{raw_prompt}",
                                        Priority:       1,
                                        Dependencies:   []string{},
                                },
                        },
                },
                string(IntentSearch): {
                        Intent: IntentSearch,
                        Tasks: []TaskTemplate{
                                {
                                        Agent:          "search",
                                        PromptTemplate: "{raw_prompt}",
                                        Priority:       1,
                                        Dependencies:   []string{},
                                },
                        },
                },
                string(IntentAnalysis): {
                        Intent: IntentAnalysis,
                        Tasks: []TaskTemplate{
                                {
                                        Agent:          "code_analysis",
                                        PromptTemplate: "{raw_prompt}",
                                        Priority:       1,
                                        Dependencies:   []string{},
                                },
                        },
                },
                string(IntentTest): {
                        Intent: IntentTest,
                        Tasks: []TaskTemplate{
                                {
                                        Agent:          "dispatcher",
                                        PromptTemplate: "{raw_prompt}",
                                        Priority:       1,
                                        Dependencies:   []string{},
                                },
                        },
                },
                string(IntentRefactor): {
                        Intent: IntentRefactor,
                        Tasks: []TaskTemplate{
                                {
                                        Agent:          "code_analysis",
                                        PromptTemplate: "Analyze code for refactoring: {raw_prompt}",
                                        Priority:       1,
                                        Dependencies:   []string{},
                                },
                                {
                                        Agent:          "file_operations",
                                        PromptTemplate: "Apply refactoring changes",
                                        Priority:       2,
                                        Dependencies:   []string{},
                                },
                        },
                },
                string(IntentGeneric): {
                        Intent: IntentGeneric,
                        Tasks: []TaskTemplate{
                                {
                                        Agent:          "dispatcher",
                                        PromptTemplate: "{raw_prompt}",
                                        Priority:       1,
                                        Dependencies:   []string{},
                                },
                        },
                },
        }
}</pre>
		
		<pre class="file" id="file15" style="display: none">package agents

import (
        "sync"
        "time"
)

// Message represents a message between agents
type Message struct {
        ID           string
        Type         MessageType
        Source       string
        Target       string
        Payload      interface{}
        Context      *ExecutionContext
        Priority     Priority
        Timestamp    time.Time
}

// MessageType defines the type of message
type MessageType string

const (
        MessageTypeRequest  MessageType = "request"
        MessageTypeResponse MessageType = "response"
        MessageTypeFeedback MessageType = "feedback"
        MessageTypeError    MessageType = "error"
        MessageTypeProgress MessageType = "progress"
)

// Priority defines message priority
type Priority int

const (
        PriorityLow    Priority = 0
        PriorityMedium Priority = 5
        PriorityHigh   Priority = 10
)

// ExecutionContext represents the shared execution context
type ExecutionContext struct {
        SessionID   string
        RequestID   string
        UserPrompt  string
        SharedData  map[string]interface{}
        FileContext []FileInfo
        Artifacts   map[string]interface{}
        Progress    chan&lt;- ProgressUpdate
        Options     map[string]interface{}
        mu          sync.RWMutex
}

// FileInfo represents information about a file
type FileInfo struct {
        Path         string
        LastModified time.Time
        Size         int64
        Hash         string
        Content      string
}

// ProgressUpdate represents a progress update
type ProgressUpdate struct {
        TaskID    string
        Agent     string
        Status    string
        Progress  float64
        Message   string
        Timestamp time.Time
}

// Task represents a single task in an execution plan
type Task struct {
        ID           string
        Agent        string
        Request      AgentRequest
        Priority     int
        Dependencies []string
        Stage        string
        Timeout      time.Duration
}

// Stage represents a stage in the execution plan
type Stage struct {
        ID    string
        Tasks []string
}

// ExecutionPlan represents a complete execution plan
type ExecutionPlan struct {
        ID                string
        Context           *ExecutionContext
        Tasks             []Task
        Stages            []Stage
        EstimatedDuration string
        CreatedAt         time.Time
}

// TaskResult represents the result of a task execution
type TaskResult struct {
        Task      Task
        Result    AgentResult
        Error     error
        StartTime time.Time
        EndTime   time.Time
}

// ExecutionGraph represents a graph of execution nodes
type ExecutionGraph struct {
        Nodes map[string]*GraphNode
        Edges map[string][]string
}

// GraphNode represents a node in the execution graph
type GraphNode struct {
        ID           string
        Agent        string
        AgentRef     Agent
        Request      AgentRequest
        Priority     int
        Dependencies []string
}

// FeedbackRequest represents a feedback request from an agent
type FeedbackRequest struct {
        ID         string
        SourceTask string
        TargetTask string
        Type       FeedbackType
        Content    interface{}
        Context    *ExecutionContext
}

// FeedbackType defines types of feedback
type FeedbackType string

const (
        FeedbackTypeNeedMoreContext FeedbackType = "need_more_context"
        FeedbackTypeValidationError FeedbackType = "validation_error"
        FeedbackTypeRetry           FeedbackType = "retry"
        FeedbackTypeRefine          FeedbackType = "refine"
)

// MessageBus handles inter-agent communication
type MessageBus struct {
        subscribers map[string][]chan Message
        mu          sync.RWMutex
}

// NewMessageBus creates a new message bus
func NewMessageBus() *MessageBus <span class="cov0" title="0">{
        return &amp;MessageBus{
                subscribers: make(map[string][]chan Message),
        }
}</span>

// Subscribe subscribes to messages for an agent
func (mb *MessageBus) Subscribe(agentID string) &lt;-chan Message <span class="cov0" title="0">{
        mb.mu.Lock()
        defer mb.mu.Unlock()

        ch := make(chan Message, 100)
        mb.subscribers[agentID] = append(mb.subscribers[agentID], ch)
        return ch
}</span>

// Unsubscribe removes a subscription
func (mb *MessageBus) Unsubscribe(agentID string, ch &lt;-chan Message) <span class="cov0" title="0">{
        mb.mu.Lock()
        defer mb.mu.Unlock()

        channels := mb.subscribers[agentID]
        for i, c := range channels </span><span class="cov0" title="0">{
                if c == ch </span><span class="cov0" title="0">{
                        mb.subscribers[agentID] = append(channels[:i], channels[i+1:]...)
                        close(c)
                        break</span>
                }
        }
}

// Publish publishes a message to the bus
func (mb *MessageBus) Publish(msg Message) <span class="cov0" title="0">{
        mb.mu.RLock()
        defer mb.mu.RUnlock()

        msg.Timestamp = time.Now()

        // Send to target agent's subscribers
        if channels, exists := mb.subscribers[msg.Target]; exists </span><span class="cov0" title="0">{
                for _, ch := range channels </span><span class="cov0" title="0">{
                        select </span>{
                        case ch &lt;- msg:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                                // Channel full, skip
                        }
                }
        }

        // Also send to wildcard subscribers
        <span class="cov0" title="0">if channels, exists := mb.subscribers["*"]; exists </span><span class="cov0" title="0">{
                for _, ch := range channels </span><span class="cov0" title="0">{
                        select </span>{
                        case ch &lt;- msg:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0"></span>
                                // Channel full, skip
                        }
                }
        }
}</pre>
		
		<pre class="file" id="file16" style="display: none">package agents

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/killallgit/ryan/pkg/logger"
        "github.com/killallgit/ryan/pkg/tools"
)

// SearchAgent handles code search operations
type SearchAgent struct {
        toolRegistry *tools.Registry
        log          *logger.Logger
}

// NewSearchAgent creates a new search agent
func NewSearchAgent(toolRegistry *tools.Registry) *SearchAgent <span class="cov8" title="1">{
        return &amp;SearchAgent{
                toolRegistry: toolRegistry,
                log:          logger.WithComponent("search_agent"),
        }
}</span>

// Name returns the agent name
func (s *SearchAgent) Name() string <span class="cov8" title="1">{
        return "search"
}</span>

// Description returns the agent description
func (s *SearchAgent) Description() string <span class="cov8" title="1">{
        return "Searches for code patterns, symbols, and text across files"
}</span>

// CanHandle determines if this agent can handle the request
func (s *SearchAgent) CanHandle(request string) (bool, float64) <span class="cov8" title="1">{
        lowerRequest := strings.ToLower(request)
        
        keywords := []string{
                "search", "find", "grep", "locate",
                "where is", "look for", "search for",
        }
        
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                if strings.Contains(lowerRequest, keyword) </span><span class="cov8" title="1">{
                        return true, 0.8
                }</span>
        }
        
        <span class="cov8" title="1">return false, 0.0</span>
}

// Execute performs the search operation
func (s *SearchAgent) Execute(ctx context.Context, request AgentRequest) (AgentResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        s.log.Info("Executing search", "prompt", request.Prompt)

        // Extract search pattern
        pattern := s.extractSearchPattern(request.Prompt)
        if pattern == "" </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "No search pattern found",
                        Details: "Please specify what to search for",
                }, nil
        }</span>

        // Determine search scope
        <span class="cov8" title="1">scope := s.determineScope(request)

        // Use grep tool
        grepTool, exists := s.toolRegistry.Get("grep")
        if !exists </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: "Search tool not available",
                        Details: "The grep tool is not registered",
                }, fmt.Errorf("grep tool not available")
        }</span>

        // Execute search
        <span class="cov8" title="1">result, err := grepTool.Execute(ctx, map[string]interface{}{
                "pattern":      pattern,
                "path":         scope.Path,
                "glob":         scope.Glob,
                "output_mode":  "content",
                "-n":           true,  // Show line numbers
                "-i":           scope.CaseInsensitive,
                "head_limit":   100,   // Limit results
        })

        if err != nil </span><span class="cov0" title="0">{
                return AgentResult{
                        Success: false,
                        Summary: fmt.Sprintf("Search failed for pattern: %s", pattern),
                        Details: err.Error(),
                }, err
        }</span>

        // Process results
        <span class="cov8" title="1">matches := s.processSearchResults(result.Content)
        
        // Build summary and details
        summary := fmt.Sprintf("Found %d matches for '%s'", len(matches), pattern)
        details := s.buildSearchDetails(matches, pattern)

        return AgentResult{
                Success: true,
                Summary: summary,
                Details: details,
                Artifacts: map[string]interface{}{
                        "pattern": pattern,
                        "matches": matches,
                        "scope":   scope,
                },
                Metadata: AgentMetadata{
                        AgentName: s.Name(),
                        StartTime: startTime,
                        EndTime:   time.Now(),
                        Duration:  time.Since(startTime),
                        ToolsUsed: []string{"grep"},
                },
        }, nil</span>
}

// extractSearchPattern extracts the search pattern from the prompt
func (s *SearchAgent) extractSearchPattern(prompt string) string <span class="cov8" title="1">{
        // Look for quoted patterns
        if start := strings.Index(prompt, "\""); start != -1 </span><span class="cov0" title="0">{
                if end := strings.Index(prompt[start+1:], "\""); end != -1 </span><span class="cov0" title="0">{
                        return prompt[start+1 : start+1+end]
                }</span>
        }
        
        <span class="cov8" title="1">if start := strings.Index(prompt, "'"); start != -1 </span><span class="cov0" title="0">{
                if end := strings.Index(prompt[start+1:], "'"); end != -1 </span><span class="cov0" title="0">{
                        return prompt[start+1 : start+1+end]
                }</span>
        }

        // Look for pattern after keywords
        <span class="cov8" title="1">keywords := []string{" for ", " search ", " find ", " grep "}
        lowerPrompt := strings.ToLower(prompt)
        
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                if idx := strings.Index(lowerPrompt, keyword); idx != -1 </span><span class="cov8" title="1">{
                        pattern := prompt[idx+len(keyword):]
                        // Take until next space or punctuation
                        if endIdx := strings.IndexAny(pattern, " ,;."); endIdx != -1 </span><span class="cov8" title="1">{
                                pattern = pattern[:endIdx]
                        }</span>
                        <span class="cov8" title="1">return strings.TrimSpace(pattern)</span>
                }
        }

        // Last resort - take the last word
        <span class="cov0" title="0">words := strings.Fields(prompt)
        if len(words) &gt; 0 </span><span class="cov0" title="0">{
                return words[len(words)-1]
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// determineScope determines the search scope from the request
func (s *SearchAgent) determineScope(request AgentRequest) SearchScope <span class="cov8" title="1">{
        scope := SearchScope{
                Path: ".",
                Glob: "",
                CaseInsensitive: false,
        }

        prompt := strings.ToLower(request.Prompt)

        // Check for file type specifications
        if strings.Contains(prompt, "go file") || strings.Contains(prompt, ".go") </span><span class="cov0" title="0">{
                scope.Glob = "*.go"
        }</span> else<span class="cov8" title="1"> if strings.Contains(prompt, "test") </span><span class="cov0" title="0">{
                scope.Glob = "*_test.go"
        }</span> else<span class="cov8" title="1"> if strings.Contains(prompt, "javascript") || strings.Contains(prompt, ".js") </span><span class="cov0" title="0">{
                scope.Glob = "*.js"
        }</span>

        // Check for case sensitivity
        <span class="cov8" title="1">if strings.Contains(prompt, "case insensitive") || strings.Contains(prompt, "ignore case") </span><span class="cov0" title="0">{
                scope.CaseInsensitive = true
        }</span>

        // Check for path specifications
        <span class="cov8" title="1">if execContext, ok := request.Context["execution_context"].(*ExecutionContext); ok </span><span class="cov0" title="0">{
                if targetPath, ok := execContext.SharedData["target_path"].(string); ok </span><span class="cov0" title="0">{
                        scope.Path = targetPath
                }</span>
        }

        <span class="cov8" title="1">return scope</span>
}

// processSearchResults processes the raw search output
func (s *SearchAgent) processSearchResults(output string) []SearchMatch <span class="cov8" title="1">{
        matches := []SearchMatch{}
        lines := strings.Split(output, "\n")

        currentFile := ""
        for _, line := range lines </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse grep output format: filename:line_number:content
                <span class="cov8" title="1">parts := strings.SplitN(line, ":", 3)
                if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                        file := parts[0]
                        lineNum := parts[1]
                        content := parts[2]

                        if file != currentFile </span><span class="cov8" title="1">{
                                currentFile = file
                        }</span>

                        <span class="cov8" title="1">matches = append(matches, SearchMatch{
                                File:    file,
                                Line:    lineNum,
                                Content: strings.TrimSpace(content),
                        })</span>
                }
        }

        <span class="cov8" title="1">return matches</span>
}

// buildSearchDetails builds detailed search results
func (s *SearchAgent) buildSearchDetails(matches []SearchMatch, pattern string) string <span class="cov8" title="1">{
        if len(matches) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("No matches found for pattern: %s", pattern)
        }</span>

        <span class="cov8" title="1">var details []string
        details = append(details, fmt.Sprintf("Search results for: '%s'", pattern))
        details = append(details, fmt.Sprintf("Found %d matches:", len(matches)))
        details = append(details, "")

        // Group by file
        fileGroups := make(map[string][]SearchMatch)
        for _, match := range matches </span><span class="cov8" title="1">{
                fileGroups[match.File] = append(fileGroups[match.File], match)
        }</span>

        // Display results grouped by file
        <span class="cov8" title="1">for file, fileMatches := range fileGroups </span><span class="cov8" title="1">{
                details = append(details, fmt.Sprintf("File: %s (%d matches)", file, len(fileMatches)))
                for _, match := range fileMatches </span><span class="cov8" title="1">{
                        details = append(details, fmt.Sprintf("  Line %s: %s", match.Line, match.Content))
                }</span>
                <span class="cov8" title="1">details = append(details, "")</span>
        }

        <span class="cov8" title="1">return strings.Join(details, "\n")</span>
}

// Supporting types

type SearchScope struct {
        Path            string
        Glob            string
        CaseInsensitive bool
}

type SearchMatch struct {
        File    string
        Line    string
        Content string
}</pre>
		
		<pre class="file" id="file17" style="display: none">package agents

import (
        "fmt"
        "time"
)

// truncateString truncates a string to a maximum length
func truncateString(s string, maxLen int) string <span class="cov8" title="1">{
        if len(s) &lt;= maxLen </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLen] + "..."</span>
}

// generateID generates a unique ID
func generateID() string <span class="cov8" title="1">{
        return fmt.Sprintf("%d", time.Now().UnixNano())
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
